use crate::logger::Logger;
use crate::processing::filetype;
use crate::utils::convert_webp_to_png;
use html2md;
use lazy_static::lazy_static;
use percent_encoding::percent_decode;
use rayon::prelude::*;
use regex::Regex;
use scraper::{Html, Selector};
use std::fs;
use std::path::{Path, PathBuf};
use std::sync::atomic::{AtomicUsize, Ordering};
use std::sync::{Arc, Mutex};
use walkdir::WalkDir;

// Cached regex patterns for improved performance
lazy_static! {
    // Matches markdown image syntax: ![alt](path)
    // Uses greedy matching to support filenames with parentheses like "file(1).png"
    static ref RE_MD_IMAGE: Regex = Regex::new(r"!\[([^\]]*)\]\(([^\n]+)\)").unwrap();

    // Matches markdown link syntax: [text](path)
    // Uses greedy matching to support filenames with parentheses like "file(1).png"
    static ref RE_MD_LINK: Regex = Regex::new(r"\[([^\]]+)\]\(([^\n]+)\)").unwrap();

    // Matches generic image pattern generated by html2md: ![...](image_N.ext)
    static ref RE_GENERIC_IMAGE: Regex = Regex::new(r"!\[([^\]]*)\]\(image_(\d+)\.(png|jpg|jpeg|gif|bmp|webp|tiff|svg)\)").unwrap();

    // Matches generic image pattern with or without extension: ![...](image_N) or ![...](image_N.ext)
    static ref RE_GENERIC_IMAGE_FLEXIBLE: Regex = Regex::new(r"!\[([^\]]*)\]\(image_(\d+)(?:\.[a-z]+)?\)").unwrap();

    // Matches attachment filenames: {comment_id}_attachments_{filename}
    static ref RE_ATTACHMENT_FILENAME: Regex = Regex::new(r"(\d+)_attachments_([^\s\)]+)").unwrap();
}

/// Checks if a directory is empty recursively (contains no files at all).
/// Returns true if the directory and all subdirectories contain zero files.
fn is_directory_empty_recursive(dir: &Path) -> bool {
    WalkDir::new(dir)
        .into_iter()
        .filter_map(Result::ok)
        .all(|entry| !entry.file_type().is_file())
}

/// Represents a single HTML page with its content, comments, and attachments.
/// This struct is used to store extracted information from HTML files during
/// the document processing phase.
#[derive(Debug)]
pub struct Page {
    /// The title/name of the page
    pub name: String,
    /// The main content of the page in markdown format
    pub content: String,
    /// List of comments associated with this page, stored as (comment_id, comment_content) pairs
    pub comments: Vec<(String, String)>,
    /// List of file paths to attachments (images, documents) referenced by this page
    pub attachments: Vec<PathBuf>,
}

pub fn process_directories_unified(data_dir: &Path, mode: Option<bool>, output_dir: &Path) {
    // Validate input directory exists
    if !data_dir.exists() {
        Logger::error(&format!("Data directory not found: {}", data_dir.display()));
        return;
    }

    // First pass: correct image extensions in all attachment directories (parallel)
    Logger::info("Scanning for images with incorrect extensions");

    // Collect all directories first
    let directories: Vec<PathBuf> = WalkDir::new(data_dir)
        .min_depth(1)
        .max_depth(1)
        .into_iter()
        .filter_map(Result::ok)
        .filter(|e| e.file_type().is_dir())
        .map(|e| e.path().to_path_buf())
        .collect();

    // Parallel image correction
    let total_corrected: usize = directories
        .par_iter()
        .map(|dir| {
            let attachments_dir = dir.join("attachments");
            if attachments_dir.exists() {
                super::super::processing::images::correct_image_extensions_in_directory(
                    &attachments_dir,
                )
            } else {
                0
            }
        })
        .sum();

    if total_corrected > 0 {
        Logger::success(&format!(
            "Corrected {} image file extensions",
            total_corrected
        ));
    }

    // Collect directories to process based on mode
    let dirs_to_process: Vec<(PathBuf, bool)> = directories
        .iter()
        .filter_map(|dir| {
            let file_name = dir.file_name()?.to_string_lossy();
            let is_employee_dir = file_name.starts_with('~');

            // Determine if we should process this directory based on mode
            let should_process = match mode {
                None => true,                    // Process all
                Some(true) => is_employee_dir,   // Employee only
                Some(false) => !is_employee_dir, // Project only
            };

            if should_process {
                Some((dir.clone(), is_employee_dir))
            } else {
                None
            }
        })
        .collect();

    let total_dirs = dirs_to_process.len();
    if total_dirs == 0 {
        Logger::warning("No directories to process");
        return;
    }

    // Parallel directory processing with progress tracking
    let processed = AtomicUsize::new(0);
    let empty_dirs = Arc::new(Mutex::new(Vec::new()));
    let failures = Arc::new(Mutex::new(Vec::new()));

    dirs_to_process
        .par_iter()
        .for_each(|(dir, is_employee_dir)| {
            let current = processed.fetch_add(1, Ordering::Relaxed) + 1;
            Logger::parallel_progress(current, total_dirs, "HTML to Markdown");

            // Check if directory is completely empty (no files recursively)
            if is_directory_empty_recursive(dir) {
                let dir_name = dir.file_name().unwrap().to_string_lossy().to_string();
                empty_dirs.lock().unwrap().push(dir_name);
                return;
            }

            // Extract content from the directory
            match process_directory(dir) {
                Some((alias, chinese_name, file_count, markdown_content)) => {
                    // Generate output filename based on directory type
                    let output_file_name = if *is_employee_dir {
                        format!("{}-{}-{}.md", alias, chinese_name, file_count)
                    } else {
                        format!("{}-{}.md", alias, file_count)
                    };
                    let output_path = output_dir.join(output_file_name);

                    // Decode HTML entities and prepare final content
                    let mut final_content =
                        markdown_content.replace("&gt;", ">").replace("&lt;", "<");

                    // Copy linked resources and update links
                    match copy_resources_and_update_links(&final_content, &output_path, dir) {
                        Ok(updated_content) => {
                            final_content = updated_content;
                        }
                        Err(e) => {
                            Logger::warning(&format!(
                                "Failed to copy resources for {}: {}",
                                dir.file_name().unwrap().to_string_lossy(),
                                e
                            ));
                            // Continue with original content
                        }
                    }

                    // Write the final content to file
                    match fs::write(&output_path, final_content) {
                        Ok(_) => {
                            // Success - no need to log individual success in parallel mode
                        }
                        Err(e) => {
                            let dir_name = dir.file_name().unwrap().to_string_lossy().to_string();
                            failures
                                .lock()
                                .unwrap()
                                .push((dir_name, format!("Failed to write file: {}", e)));
                        }
                    }
                }
                None => {
                    let dir_name = dir.file_name().unwrap().to_string_lossy().to_string();
                    failures
                        .lock()
                        .unwrap()
                        .push((dir_name, "Failed to extract content".to_string()));
                }
            }
        });

    // Report results with three categories
    let failures_vec = Arc::try_unwrap(failures).unwrap().into_inner().unwrap();
    let empty_vec = Arc::try_unwrap(empty_dirs).unwrap().into_inner().unwrap();
    let successful = total_dirs - failures_vec.len() - empty_vec.len();
    
    println!("\n✓ Completed HTML to Markdown conversion operations:");
    println!("    ✓ {} successful", successful);
    if !empty_vec.is_empty() {
        println!("    ? {} empty", empty_vec.len());
    }
    if !failures_vec.is_empty() {
        println!("    ✗ {} failed", failures_vec.len());
    }
    println!("    ● {} total", total_dirs);
    
    // Only show failures, not empty directories
    if !failures_vec.is_empty() {
        Logger::parallel_failures(&failures_vec);
    }
}

/// Processes a single employee or project directory to extract and consolidate HTML content.
///
/// This function analyzes a directory containing HTML files (typically from documentation
/// systems) and converts them into a consolidated markdown format. It handles:
/// - Index file parsing for page ordering
/// - Chinese name extraction from homepage files
/// - Comment processing (HTML files with redirect meta tags)
/// - Attachment association with comments
/// - HTML to markdown conversion
/// - Proper ordering of pages and content
///
/// The process involves:
/// 1. Extracting directory alias and validating index.html exists
/// 2. Counting total files and finding Chinese name from homepage
/// 3. Parsing index.html to determine page ordering
/// 4. Processing all HTML files to separate pages from comments
/// 5. Associating comments with their target pages
/// 6. Processing attachments directory and linking attachments to comments
/// 7. Converting all content to markdown with proper formatting
///
/// # Arguments
/// * `dir` - Path to the directory to process
///
/// # Returns
/// * `Option<(String, String, usize, String)>` - Returns (alias, chinese_name, file_count, markdown_content)
///   or None if processing fails
///
/// # File Structure Expected
/// - index.html: Contains ordered list of page names
/// - N.html: Content pages (where N is numeric)
/// - N.html: Comment pages (numeric filenames with redirect meta tags)
/// - homepage files: "NAME的主页.html" or "NAME's Home.html" for Chinese name extraction
/// - attachments/: Directory containing files referenced by comments
fn process_directory(dir: &Path) -> Option<(String, String, usize, String)> {
    // Extract directory name as alias
    let alias = dir.file_name().unwrap().to_string_lossy().to_string();
    let index_path = dir.join("index.html");
    if !index_path.exists() {
        println!("✗ index.html not found in {}", dir.display());
        return None;
    }

    // Single pass: count files AND find Chinese name in one WalkDir iteration
    let mut file_count = 0;
    let mut chinese_name = String::new();

    for entry in WalkDir::new(dir)
        .max_depth(1)
        .into_iter()
        .filter_map(Result::ok)
    {
        if entry.file_type().is_file() {
            file_count += 1;

            // Check for homepage file while counting
            if chinese_name.is_empty() {
                let path_str = entry.path().to_string_lossy();
                if path_str.ends_with("的主页.html") || path_str.ends_with("'s Home.html") {
                    if let Some(stem) = entry.path().file_stem() {
                        let s = stem.to_string_lossy();
                        if let Some(name) = s.strip_suffix("的主页") {
                            chinese_name = name.to_string();
                        } else if let Some(name) = s.strip_suffix("'s Home") {
                            chinese_name = name.to_string();
                        }
                    }
                }
            }
        }
    }

    // Recursively count remaining files in subdirectories
    for entry in WalkDir::new(dir)
        .min_depth(2)
        .into_iter()
        .filter_map(Result::ok)
    {
        if entry.file_type().is_file() {
            file_count += 1;
        }
    }

    if chinese_name.is_empty() {
        println!("⚠  Could not find Chinese name in {}", dir.display());
        // Fallback to alias if no chinese name is found
        chinese_name = alias.clone();
    }

    let index_content = fs::read_to_string(&index_path).unwrap();
    let index_html = Html::parse_document(&index_content);
    let body_selector = Selector::parse("body").unwrap();
    let body = index_html.select(&body_selector).next().unwrap();
    let text = body.text().collect::<String>();
    let mut ordered_pages: Vec<String> = text
        .lines()
        .map(|s| s.trim().to_string())
        .filter(|s| !s.is_empty())
        .collect();

    if !ordered_pages.is_empty() {
        ordered_pages.remove(0);
    }

    let ordered_pages: Vec<String> = ordered_pages
        .into_iter()
        .map(|s| format!("{}.html", s))
        .collect();

    let mut pages: Vec<Page> = Vec::new();
    let mut comments: Vec<(String, String, String)> = Vec::new();

    for entry in WalkDir::new(dir)
        .min_depth(1)
        .max_depth(1)
        .into_iter()
        .filter_map(Result::ok)
    {
        if entry.path().extension().map_or(false, |e| e == "html") {
            let path = entry.path();
            let file_name = path.file_stem().unwrap().to_string_lossy().to_string();

            let content = fs::read_to_string(path).unwrap();
            let html = Html::parse_document(&content);
            let meta_selector = Selector::parse("meta[http-equiv='refresh']").unwrap();

            if file_name.chars().all(char::is_numeric)
                && html.select(&meta_selector).next().is_some()
            {
                if let Some(meta) = html.select(&meta_selector).next() {
                    if let Some(content_attr) = meta.value().attr("content") {
                        if let Some(url_part) = content_attr.split("url=").nth(1) {
                            let target_page = percent_decode(url_part.as_bytes())
                                .decode_utf8_lossy()
                                .to_string();
                            let body_selector = Selector::parse("body").unwrap();
                            let body_content = html
                                .select(&body_selector)
                                .next()
                                .map_or(String::new(), |b| b.inner_html());
                            comments.push((file_name.clone(), target_page, body_content));
                        }
                    }
                }
            } else {
                let body_selector = Selector::parse("body").unwrap();
                let body_content = html
                    .select(&body_selector)
                    .next()
                    .map_or(String::new(), |b| b.inner_html());
                pages.push(Page {
                    name: path.file_name().unwrap().to_string_lossy().to_string(),
                    content: body_content,
                    comments: Vec::new(),
                    attachments: Vec::new(),
                });
            }
        }
    }

    for (comment_id, target_page, comment_content) in comments {
        if let Some(page) = pages.iter_mut().find(|p| p.name == target_page) {
            page.comments.push((comment_id, comment_content));
        }
    }

    let attachments_dir = dir.join("attachments");
    if attachments_dir.exists() {
        for entry in WalkDir::new(attachments_dir)
            .min_depth(1)
            .max_depth(1)
            .into_iter()
            .filter_map(Result::ok)
        {
            let path = entry.path();

            // Correct image extension if needed (for images with mismatched extensions)
            let corrected_path = if let Ok(path_buf) = path.canonicalize() {
                // Check if this is an image file
                if let Some(ext) = path_buf.extension() {
                    let ext_str = ext.to_string_lossy().to_lowercase();
                    if ["png", "jpg", "jpeg", "gif", "bmp", "webp", "tiff"]
                        .contains(&ext_str.as_str())
                    {
                        // Try to detect and fix the extension
                        match super::super::processing::images::detect_and_rename_image(&path_buf) {
                            Ok(new_path) => new_path,
                            Err(_) => path_buf, // Keep original if detection fails
                        }
                    } else {
                        path_buf
                    }
                } else {
                    path_buf
                }
            } else {
                path.to_path_buf()
            };

            let file_name = corrected_path.file_name().unwrap().to_string_lossy();
            if let Some(comment_id) = file_name.split('_').next() {
                for page in pages.iter_mut() {
                    if page.comments.iter().any(|(id, _)| id == comment_id) {
                        page.attachments.push(corrected_path.clone());
                    }
                }
            }
        }
    }

    pages.sort_by_key(|p| {
        ordered_pages
            .iter()
            .position(|name| name == &p.name)
            .unwrap_or(usize::MAX)
    });

    // Add document title at the top for PDF bookmark hierarchy
    let mut markdown_content = String::new();
    
    // Create a top-level title:
    // - For employees with Chinese name: "~alias 中文名"
    // - For employees without Chinese name or projects: Just the directory name
    let doc_title = if !chinese_name.is_empty() && chinese_name != alias {
        // Employee directory with Chinese name found
        format!("{} {}", alias, chinese_name)
    } else {
        // Project directory or employee without Chinese name - use directory name
        alias.clone()
    };
    markdown_content.push_str(&format!("# {}\n\n", doc_title));
    
    for page in pages {
        if page.name == "index.html" {
            continue;
        }
        markdown_content.push_str(&format!("## {}\n\n", page.name.replace(".html", "")));

        // Extract original image URLs from HTML before conversion
        let original_image_urls = extract_image_urls_from_html(&page.content);

        // Collect image attachments for fallback generic name replacement
        let image_attachments: Vec<PathBuf> = page
            .attachments
            .iter()
            .filter(|p| {
                let ext = p
                    .extension()
                    .map_or("", |s| s.to_str().unwrap())
                    .to_lowercase();
                ["png", "jpg", "jpeg", "gif", "bmp", "webp", "tiff", "svg"].contains(&ext.as_str())
            })
            .cloned()
            .collect();

        // Remove first H1 tag from HTML to prevent duplicate titles
        // Since we add our own ## header above, we don't want the H1 from HTML
        let html_without_first_h1 = remove_first_h1_from_html(&page.content);

        // Convert to markdown and restore correct image URLs
        let mut page_markdown = html2md::parse_html(&html_without_first_h1)
            .replace("\r\n", "\n")
            .replace("\n", "\n\n");

        // Clean excessive backticks that break markdown parsing
        page_markdown = clean_excessive_backticks(&page_markdown);
        
        // Sanitize LaTeX-problematic patterns before PDF generation
        page_markdown = sanitize_latex_problematic_patterns(&page_markdown);

        // Try to restore using original URLs first, then fallback to attachment mapping
        if !original_image_urls.is_empty() {
            page_markdown = restore_image_urls_in_markdown(&page_markdown, &original_image_urls);
        } else if !image_attachments.is_empty() {
            page_markdown =
                map_generic_images_to_corrected_attachments(&page_markdown, &image_attachments);
        }
        
        // Verify image formats and convert non-images to regular links
        // IMPORTANT: This must be called AFTER restoring URLs so we have actual filenames
        page_markdown = verify_and_fix_image_formats(&page_markdown, dir);

        // NOTE: We don't convert attachment filenames in page content because:
        // 1. Bare filenames in page content are artifacts from HTML rendering
        // 2. Those attachments will appear properly formatted in the "### Attachments" section
        // 3. Converting them to links causes issues with resource copying (nested links)
        // The bare filenames should just appear as-is in the page content

        markdown_content.push_str(&page_markdown);
        markdown_content.push_str("\n\n");

        for (comment_id, comment) in &page.comments {
            markdown_content.push_str("### Comment\n\n");

            // Extract original image URLs from HTML before conversion
            let original_comment_urls = extract_image_urls_from_html(&comment);

            // Convert to markdown and restore correct image URLs
            let mut comment_markdown = html2md::parse_html(&comment)
                .replace("\r\n", "\n")
                .replace("\n", "\n\n");

            // Clean excessive backticks that break markdown parsing
            comment_markdown = clean_excessive_backticks(&comment_markdown);
            
            // Sanitize LaTeX-problematic patterns before PDF generation
            comment_markdown = sanitize_latex_problematic_patterns(&comment_markdown);

            // Try to restore using original URLs first, then fallback to attachment mapping
            if !original_comment_urls.is_empty() {
                comment_markdown =
                    restore_image_urls_in_markdown(&comment_markdown, &original_comment_urls);
            } else if !image_attachments.is_empty() {
                comment_markdown = map_generic_images_to_corrected_attachments(
                    &comment_markdown,
                    &image_attachments,
                );
            }
            
            // Verify image formats and convert non-images to regular links
            // IMPORTANT: This must be called AFTER restoring URLs so we have actual filenames
            comment_markdown = verify_and_fix_image_formats(&comment_markdown, dir);

            // Convert any attachment filenames in the comment to markdown links
            let comment_with_links =
                convert_attachment_filenames_to_links(&comment_markdown, &alias, &comment_id);
            markdown_content.push_str(&comment_with_links);
            markdown_content.push_str("\n\n");
        }

        if !page.attachments.is_empty() {
            markdown_content.push_str("### Attachments\n\n");

            // Separate images and non-images for better PDF rendering
            let mut images = Vec::new();
            let mut files = Vec::new();

            for attachment in page.attachments.iter() {
                let file_name = attachment.file_name().unwrap().to_string_lossy();
                let extension = attachment
                    .extension()
                    .map_or("", |s| s.to_str().unwrap())
                    .to_lowercase();
                // Use just the filename - copy_resources_and_update_links will resolve the correct path
                // This avoids issues where the alias doesn't match the output filename
                // (e.g., alias="NEZ" but output is "NEZ-3359.md" -> "NEZ-3359_files/")
                let link = file_name.to_string();

                if ["png", "jpg", "jpeg", "gif", "bmp", "webp", "tiff", "svg"]
                    .contains(&extension.as_str())
                {
                    images.push((file_name.to_string(), link));
                } else {
                    files.push((file_name.to_string(), link));
                }
            }

            // Output images first
            for (file_name, link) in images {
                markdown_content.push_str(&format!("![{}]({})\n\n", file_name, link));
            }

            // Then output other files as links
            for (file_name, link) in files {
                markdown_content.push_str(&format!("[{}]({})\n\n", file_name, link));
            }
        }

        markdown_content.push_str("\n---\n\n");
    }

    Some((alias, chinese_name, file_count, markdown_content))
}

/// Extracts all local file links from markdown content.
/// Returns a vector of link paths that appear to be local file references (not URLs).
fn extract_local_links(markdown_content: &str) -> Vec<String> {
    let mut links = Vec::new();

    // Match markdown image syntax: ![alt](path)
    for cap in RE_MD_IMAGE.captures_iter(markdown_content) {
        let link = cap[2].to_string();
        if !is_external_url(&link) {
            links.push(link);
        }
    }

    // Match markdown link syntax: [text](path)
    for cap in RE_MD_LINK.captures_iter(markdown_content) {
        let link = cap[2].to_string();
        if !is_external_url(&link) {
            links.push(link);
        }
    }

    // Remove duplicates while preserving order
    let mut seen = std::collections::HashSet::new();
    links
        .into_iter()
        .filter(|link| seen.insert(link.clone()))
        .collect()
}

/// Removes the first H1 tag from HTML content to prevent duplicate titles.
/// When we add our own markdown header (##), we don't want the H1 from the HTML
/// to create a duplicate title in the converted markdown.
/// The H1's text content is preserved as regular text.
fn remove_first_h1_from_html(html_content: &str) -> String {
    let html = Html::parse_document(html_content);
    let h1_selector = Selector::parse("h1").unwrap();
    
    // Find the first h1 element
    if let Some(h1) = html.select(&h1_selector).next() {
        // Get the HTML representation of the h1 tag and its text content
        let h1_html = h1.html();
        let h1_text = h1.text().collect::<Vec<_>>().join(" ");
        // Replace the h1 tag with just its text content (no header formatting)
        html_content.replacen(&h1_html, &h1_text, 1)
    } else {
        html_content.to_string()
    }
}

/// Clean lines containing excessive backticks (2 or more consecutive backticks)
/// These are often artifacts from HTML-to-markdown conversion that break markdown parsing
fn clean_excessive_backticks(markdown: &str) -> String {
    markdown
        .lines()
        .filter(|line| {
            // Count consecutive backticks
            let mut max_consecutive = 0;
            let mut current_consecutive = 0;

            for ch in line.chars() {
                if ch == '`' {
                    current_consecutive += 1;
                    max_consecutive = max_consecutive.max(current_consecutive);
                } else {
                    current_consecutive = 0;
                }
            }

            // Keep line only if it has less than 2 consecutive backticks
            max_consecutive < 2
        })
        .collect::<Vec<&str>>()
        .join("\n")
}

/// Sanitizes markdown to prevent LaTeX issues by fixing problematic patterns.
/// This addresses three main issues:
/// 1. Pre-escaped LaTeX characters (like \~ and \_) that shouldn't be double-escaped
/// 2. Quote-backtick sequences that cause LaTeX "Double superscript" errors
/// 3. Other LaTeX-problematic patterns in generated markdown
fn sanitize_latex_problematic_patterns(markdown: &str) -> String {
    let mut result = String::with_capacity(markdown.len());
    let chars: Vec<char> = markdown.chars().collect();
    let len = chars.len();
    let mut i = 0;
    
    while i < len {
        let ch = chars[i];
        
        // Handle pre-escaped LaTeX characters: convert them to un-escaped form
        // so that escape_latex_special_chars() can process them uniformly
        if ch == '\\' && i + 1 < len {
            let next_ch = chars[i + 1];
            // Check if this is a pre-escaped LaTeX special char
            match next_ch {
                '~' | '_' | '>' | '&' | '#' | '%' | '{' | '}' | '$' => {
                    // Convert \~ to ~, \_ to _, \> to >, \& to &, \$ to $, etc.
                    // This prevents double-escaping later
                    result.push(next_ch);
                    i += 2;
                    continue;
                }
                _ => {
                    // Keep other backslash sequences as-is
                    result.push(ch);
                    i += 1;
                    continue;
                }
            }
        }
        
        // Handle quote-backtick sequences that cause LaTeX superscript issues
        // Pattern: '` causes issues, especially in SQL contexts like COUNT(1)'`
        if ch == '\'' && i + 1 < len && chars[i + 1] == '`' {
            // Replace '` with just ' (remove the backtick)
            result.push('\'');
            i += 2; // Skip both ' and `
            continue;
        }
        
        // Handle backtick-quote sequences as well
        if ch == '`' && i + 1 < len && chars[i + 1] == '\'' {
            // Replace `' with just ' (remove the backtick)
            result.push('\'');
            i += 2; // Skip both ` and '
            continue;
        }
        
        // Default: keep the character as-is
        result.push(ch);
        i += 1;
    }
    
    result
}

/// Extracts image URLs from raw HTML content before conversion to markdown.
/// This preserves the original image filenames that would otherwise be replaced
/// by html2md with generic names like image_0.png, image_1.png, etc.
///
/// # Returns
/// A vector of (index, original_url) tuples where index is the order in which images appear
fn extract_image_urls_from_html(html_content: &str) -> Vec<(usize, String)> {
    let html = Html::parse_document(html_content);
    let img_selector = Selector::parse("img").unwrap();

    let mut urls = Vec::new();
    for (idx, img) in html.select(&img_selector).enumerate() {
        if let Some(src) = img.value().attr("src") {
            urls.push((idx, src.to_string()));
        }
    }
    urls
}

/// Replaces generic image names generated by html2md with actual attachment filenames.
/// html2md converts images to ![](image_0.png), ![](image_1.png), etc.
/// This function maps those generic names to actual file names from attachments.
///
/// # Arguments
/// * `markdown_content` - The markdown generated by html2md with generic image names
/// * `original_urls` - The original image URLs extracted from the HTML
/// * `attachments` - List of actual attachment files that will be used
///
/// # Returns
/// Modified markdown with correct image filenames
fn restore_image_urls_in_markdown(
    markdown_content: &str,
    original_urls: &[(usize, String)],
) -> String {
    let mut result = markdown_content.to_string();

    // Match the generic image pattern: ![...](image_N.png) or ![...](image_N.jpg), etc.
    for cap in RE_GENERIC_IMAGE.captures_iter(markdown_content) {
        let full_match = cap.get(0).unwrap().as_str();
        let alt_text = cap.get(1).map(|m| m.as_str()).unwrap_or("");
        let index_str = cap.get(2).map(|m| m.as_str()).unwrap_or("0");

        if let Ok(index) = index_str.parse::<usize>() {
            // Find the corresponding original URL
            if let Some((_idx, original_url)) = original_urls.iter().find(|(i, _)| *i == index) {
                // Extract just the filename from the URL (in case it contains path separators)
                let filename = original_url.split('/').last().unwrap_or(original_url);

                // Reconstruct the markdown with the original filename
                let replacement = format!("![{}]({})", alt_text, filename);
                result = result.replace(full_match, &replacement);
            }
        }
    }

    result
}

/// Maps corrected attachment filenames back to generic image names for proper link updating.
/// When attachments are corrected (e.g., temp_0 → temp_0.png), we need to update markdown
/// to use the corrected filenames so that copy_resources_and_update_links can find them.
///
/// # Arguments  
/// * `markdown_content` - The markdown potentially containing generic image names
/// * `image_attachments` - List of corrected attachment file paths
///
/// # Returns
/// Modified markdown with proper image filenames matching attachments
fn map_generic_images_to_corrected_attachments(
    markdown_content: &str,
    image_attachments: &[PathBuf],
) -> String {
    if image_attachments.is_empty() {
        return markdown_content.to_string();
    }

    let mut result = markdown_content.to_string();

    // Match generic image pattern: ![...](image_N.ext) or ![...](image_N)
    let mut replacements: Vec<(String, String)> = Vec::new();

    for cap in RE_GENERIC_IMAGE_FLEXIBLE.captures_iter(markdown_content) {
        let full_match = cap.get(0).unwrap().as_str();
        let alt_text = cap.get(1).map(|m| m.as_str()).unwrap_or("");
        let index_str = cap.get(2).map(|m| m.as_str()).unwrap_or("0");

        if let Ok(index) = index_str.parse::<usize>() {
            // Find the attachment at this index
            if let Some(attachment) = image_attachments.get(index) {
                if let Some(filename) = attachment.file_name() {
                    let filename_str = filename.to_string_lossy();
                    let new_link = format!("![{}]({})", alt_text, filename_str);
                    replacements.push((full_match.to_string(), new_link));
                }
            }
        }
    }

    // Apply all replacements
    for (old, new) in replacements {
        result = result.replace(&old, &new);
    }

    result
}

/// Checks if a link is an external URL (starts with http://, https://, etc.)
fn is_external_url(link: &str) -> bool {
    link.starts_with("http://")
        || link.starts_with("https://")
        || link.starts_with("ftp://")
        || link.starts_with("mailto:")
}

/// Verifies image file formats and converts non-image files to regular links.
/// This function checks if files referenced as images in markdown are actually images
/// by detecting their file type using magic bytes. Non-image files are converted from
/// image links ![...](file) to regular links [file](file).
///
/// # Arguments
/// * `markdown_content` - The markdown content to process
/// * `base_dir` - The base directory where attachment files are located
///
/// # Returns
/// Modified markdown with non-image files converted to regular links
fn verify_and_fix_image_formats(
    markdown_content: &str,
    base_dir: &Path,
) -> String {
    use crate::processing::filetype::detect_file_type;
    use regex::Regex;
    
    lazy_static! {
        // Match markdown image syntax: ![alt](filename)
        // Use greedy matching to support filenames with parentheses
        static ref RE_IMAGE_LINK: Regex = Regex::new(r"!\[([^\]]*)\]\(([^\n]+)\)").unwrap();
    }
    
    let mut result = markdown_content.to_string();
    let mut replacements: Vec<(String, String)> = Vec::new();
    
    for cap in RE_IMAGE_LINK.captures_iter(markdown_content) {
        let full_match = cap.get(0).unwrap().as_str();
        let alt_text = cap.get(1).map(|m| m.as_str()).unwrap_or("");
        let filename = cap.get(2).map(|m| m.as_str()).unwrap_or("");
        
        // Skip external URLs
        if is_external_url(filename) {
            continue;
        }
        
        // Try multiple paths to find the file
        // 1. Direct path in base_dir
        // 2. In attachments subdirectory
        // 3. In sibling _files directories
        let mut file_path = base_dir.join(filename);
        
        if !file_path.exists() {
            // Try attachments subdirectory
            let attachments_path = base_dir.join("attachments").join(filename);
            if attachments_path.exists() {
                file_path = attachments_path;
            } else {
                // Try sibling _files directories
                if let Some(parent) = base_dir.parent() {
                    if let Some(current_dir_name) = base_dir.file_name() {
                        let current_name = current_dir_name.to_string_lossy();
                        if let Ok(entries) = std::fs::read_dir(parent) {
                            for entry in entries.flatten() {
                                if let Ok(file_type) = entry.file_type() {
                                    if file_type.is_dir() {
                                        let dir_name = entry.file_name().to_string_lossy().to_string();
                                        if dir_name.ends_with("_files") && dir_name.starts_with(current_name.as_ref()) {
                                            let candidate = entry.path().join(filename);
                                            if candidate.exists() {
                                                file_path = candidate;
                                                break;
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
        
        // Check if file exists
        if !file_path.exists() {
            continue;
        }
        
        // Detect the actual file type
        if let Some(detected_type) = detect_file_type(&file_path) {
            // Check if it's actually an image format
            // Only PNG, JPG, JPEG should remain as image links per user requirement
            let is_valid_image = ["png", "jpg", "jpeg"].contains(&detected_type.as_str());
            
            if !is_valid_image {
                // Convert image link to regular link
                // Use alt_text if available, otherwise use the filename
                let link_text = if !alt_text.is_empty() {
                    alt_text
                } else {
                    filename
                };
                
                // Preserve the actual file extension from the detected type
                let new_filename = if let Some(stem) = file_path.file_stem() {
                    format!("{}.{}", stem.to_string_lossy(), detected_type)
                } else {
                    filename.to_string()
                };
                
                let replacement = format!("[{}]({})", link_text, new_filename);
                replacements.push((full_match.to_string(), replacement));
                
                Logger::detail(&format!(
                    "Converting non-image to regular link: {} (detected as {})",
                    filename, detected_type
                ));
            }
        }
    }
    
    // Apply all replacements
    for (old, new) in replacements {
        result = result.replace(&old, &new);
    }
    
    result
}

/// Detects attachment filenames in markdown content and converts them to proper markdown links.
/// Attachment filenames follow the pattern: `{comment_id}_attachments_{filename}`
/// These are typically plain text in the converted markdown and need to be converted to links.
/// Handles both unescaped format (with literal underscores) and escaped format (with \_ backslashes).
///
/// # Arguments
/// * `content` - The markdown content to process
/// * `alias` - The directory alias (used for link generation)
/// * `comment_id` - The comment ID to match attachments for
///
/// # Returns
/// Modified content with attachment filenames converted to markdown links
fn convert_attachment_filenames_to_links(content: &str, alias: &str, comment_id: &str) -> String {
    use regex::Regex;

    let mut result = content.to_string();

    // Pattern 1: Match escaped filenames: comment_id\_attachments\_filename
    // This handles markdown-escaped underscores
    // Need to match the whole filename including extensions with embedded underscores
    let escaped_pattern = format!(
        r"{}\\\_attachments\\_([\w\-\.]+)",
        regex::escape(comment_id)
    );
    if let Ok(re) = Regex::new(&escaped_pattern) {
        let mut new_result = String::new();
        let mut last_end = 0;

        for cap in re.captures_iter(&result) {
            let full_match = cap.get(0).unwrap();
            let filename_part = cap.get(1).map(|m| m.as_str()).unwrap_or("");

            // Skip if this looks like it's already part of a markdown link
            let before_match = &result[..full_match.start()];
            if before_match.ends_with('[')
                || before_match.ends_with("![")
                || before_match.trim_end().ends_with("](")
            {
                continue;
            }

            // Add text before this match
            new_result.push_str(&result[last_end..full_match.start()]);

            // Determine if it's an image based on extension
            let extension = filename_part.split('.').last().unwrap_or("").to_lowercase();
            let is_image = ["png", "jpg", "jpeg", "gif", "bmp", "webp", "tiff", "svg"]
                .contains(&extension.as_str());

            // The full attachment filename is: comment_id_attachments_filename_part
            let full_filename = format!(
                "{}_{}",
                comment_id,
                format!("attachments_{}", filename_part)
            );
            let link = format!("{}/attachments/{}", alias, full_filename);

            if is_image {
                new_result.push_str(&format!("![{}]({})", full_filename, link));
            } else {
                new_result.push_str(&format!("[{}]({})", full_filename, link));
            }

            last_end = full_match.end();
        }

        new_result.push_str(&result[last_end..]);
        result = new_result;
    }

    // Pattern 2: Match unescaped filenames: comment_id_attachments_filename
    let unescaped_pattern = format!(r"{}_attachments_([^\s\[\(\)]+)", regex::escape(comment_id));
    if let Ok(re) = Regex::new(&unescaped_pattern) {
        let mut new_result = String::new();
        let mut last_end = 0;

        for cap in re.captures_iter(&result) {
            let full_match = cap.get(0).unwrap();
            let filename_part = cap.get(1).map(|m| m.as_str()).unwrap_or("");

            // Skip if this looks like it's already part of a markdown link
            let before_match = &result[..full_match.start()];
            if before_match.ends_with('[')
                || before_match.ends_with("![")
                || before_match.trim_end().ends_with("](")
            {
                continue;
            }

            // Also skip if it's already inside parentheses (like a link target)
            let after_match = &result[full_match.end()..];
            if after_match.starts_with(')') {
                continue;
            }

            // Add text before this match
            new_result.push_str(&result[last_end..full_match.start()]);

            // Determine if it's an image based on extension
            let extension = filename_part.split('.').last().unwrap_or("").to_lowercase();
            let is_image = ["png", "jpg", "jpeg", "gif", "bmp", "webp", "tiff", "svg"]
                .contains(&extension.as_str());

            // The full attachment filename is: comment_id_attachments_filename_part
            let full_filename = format!(
                "{}_{}",
                comment_id,
                format!("attachments_{}", filename_part)
            );
            let link = format!("{}/attachments/{}", alias, full_filename);

            if is_image {
                new_result.push_str(&format!("![{}]({})", full_filename, link));
            } else {
                new_result.push_str(&format!("[{}]({})", full_filename, link));
            }

            last_end = full_match.end();
        }

        new_result.push_str(&result[last_end..]);
        result = new_result;
    }

    result
}

/// Resolves a link to an absolute file path based on the original data directory.
/// Handles different link patterns used in the markdown generation.
fn resolve_link_to_path(link: &str, data_dir: &Path) -> Option<PathBuf> {
    // Handle different link patterns:

    // 1. Employee/project pattern: {alias}/attachments/{filename}
    if let Some(alias_and_rest) = link.split_once('/') {
        let (alias, rest) = alias_and_rest;
        if rest.starts_with("attachments/") {
            let filename = &rest[12..]; // Remove "attachments/" prefix

            // First, try direct path within data_dir (when data_dir is the employee/project directory itself)
            let direct_path = data_dir.join("attachments").join(filename);
            if direct_path.exists() {
                return Some(direct_path);
            }

            // Second, try searching subdirectories (when data_dir is the parent directory)
            if let Ok(entries) = std::fs::read_dir(data_dir) {
                for entry in entries.flatten() {
                    if entry.file_type().ok()?.is_dir() {
                        let dir_name = entry.file_name().to_string_lossy().to_string();
                        if dir_name.starts_with(alias) || dir_name == alias {
                            let attachment_path = entry.path().join("attachments").join(filename);
                            if attachment_path.exists() {
                                return Some(attachment_path);
                            }
                        }
                    }
                }
            }
        }
    }

    // 2. JIRA attachment pattern: attachment\{id}\{filename}
    if link.starts_with("attachment\\") {
        // This is a JIRA attachment link - we can't resolve these to source files
        // as they come from the JIRA JSON data, not local files
        return None;
    }

    // 3. Direct relative paths (fallback)
    let potential_path = data_dir.join(link);
    if potential_path.exists() {
        return Some(potential_path);
    }

    // 4. Just filename - search in common directories (attachments/, etc.)
    // This handles the case where markdown contains just the filename
    // and we need to find it in the attachments directory
    if !link.contains('/') && !link.contains('\\') {
        // Try attachments subdirectory
        let attachments_path = data_dir.join("attachments").join(link);
        if attachments_path.exists() {
            return Some(attachments_path);
        }
        
        // Try searching all subdirectories for _files directories
        if let Ok(entries) = std::fs::read_dir(data_dir) {
            for entry in entries.flatten() {
                if let Ok(file_type) = entry.file_type() {
                    if file_type.is_dir() {
                        let dir_name = entry.file_name().to_string_lossy().to_string();
                        // Check _files directories
                        if dir_name.ends_with("_files") {
                            let file_path = entry.path().join(link);
                            if file_path.exists() {
                                return Some(file_path);
                            }
                        }
                        // Check attachments subdirectories
                        let attachments_subdir = entry.path().join("attachments").join(link);
                        if attachments_subdir.exists() {
                            return Some(attachments_subdir);
                        }
                    }
                }
            }
        }
        
        // Try parent directory for sibling _files directories
        // This handles cases like NEZ/ having resources in sibling NEZ-3359_files/
        if let Some(parent) = data_dir.parent() {
            if let Some(current_dir_name) = data_dir.file_name() {
                let current_name = current_dir_name.to_string_lossy();
                if let Ok(entries) = std::fs::read_dir(parent) {
                    for entry in entries.flatten() {
                        if let Ok(file_type) = entry.file_type() {
                            if file_type.is_dir() {
                                let dir_name = entry.file_name().to_string_lossy().to_string();
                                // Check _files directories that start with current directory name
                                if dir_name.ends_with("_files") && dir_name.starts_with(current_name.as_ref()) {
                                    let file_path = entry.path().join(link);
                                    if file_path.exists() {
                                        return Some(file_path);
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
    }

    None
}

/// Recursively copies a directory and its contents.
/// Returns the number of files copied.
fn copy_dir_recursively(src: &Path, dst: &Path) -> Result<usize, std::io::Error> {
    let mut files_copied = 0;
    
    // Create destination directory
    std::fs::create_dir_all(dst)?;
    
    // Iterate through directory entries
    for entry in std::fs::read_dir(src)? {
        let entry = entry?;
        let path = entry.path();
        let file_name = entry.file_name();
        let dest_path = dst.join(&file_name);
        
        if path.is_dir() {
            // Recursively copy subdirectory
            files_copied += copy_dir_recursively(&path, &dest_path)?;
        } else {
            // Copy file
            std::fs::copy(&path, &dest_path)?;
            files_copied += 1;
        }
    }
    
    Ok(files_copied)
}

/// Copies all linked resource files to a resources folder alongside the markdown file
/// and updates the markdown content to use the new relative paths.
/// Returns the updated markdown content.
fn copy_resources_and_update_links(
    markdown_content: &str,
    output_path: &Path,
    data_dir: &Path,
) -> Result<String, Box<dyn std::error::Error>> {
    let links = extract_local_links(markdown_content);

    if links.is_empty() {
        return Ok(markdown_content.to_string());
    }

    // Create resources directory alongside the markdown file
    let base_name = output_path
        .file_stem()
        .unwrap_or_default()
        .to_string_lossy();
    let resources_dir = output_path.with_file_name(format!("{}_files", base_name));
    std::fs::create_dir_all(&resources_dir)?;

    let mut updated_content = markdown_content.to_string();
    let mut copied_count = 0;
    let mut corrected_count = 0;

    for link in links {
        if let Some(source_path) = resolve_link_to_path(&link, data_dir) {
            if source_path.exists() {
                let original_file_name = source_path.file_name().unwrap().to_string_lossy();

                // Check if it's a WebP file and convert to PNG
                let source_to_copy = if let Some(ext) = source_path.extension() {
                    if ext.to_string_lossy().to_lowercase() == "webp" {
                        match convert_webp_to_png(&source_path) {
                            Ok(png_path) => png_path,
                            Err(e) => {
                                println!(
                                    "  ⚠ Failed to convert WebP {}: {}",
                                    original_file_name, e
                                );
                                source_path.clone()
                            }
                        }
                    } else {
                        source_path.clone()
                    }
                } else {
                    source_path.clone()
                };

                // Detect if file type doesn't match extension
                // IMPORTANT: This will rename the SOURCE file to have the correct extension
                // This ensures the original output folder has corrected files, not just temp/copied versions
                let (source_to_use, final_file_name) =
                    if let Some(file_ext) = source_to_copy.extension() {
                        let ext_str = file_ext.to_string_lossy().to_lowercase();
                        // Extensions that should be preserved even if detected differently
                        let preserve_extensions = ["c", "cpp", "md", "log", "deb", "yaml", "yml", "vsdx", "ps1", "vib", "cfg", "repo", "sketch", "ini", "csv", "lua", "php", "cer", "cnf", "sql", "html", "htm", "txt", "doc", "py", "j2", "whl", "saz", "sh", "ftl", "xmind", "docx", "xlsx", "pptx", "xls", "ppt", "zip", "rar", "7z", "gz", "tar", "bz2","mhtml", "pcap", "pcapng", "xml", "rpm"];
                        
                        if preserve_extensions.contains(&ext_str.as_str()) {
                            // Keep the original extension and source path
                            let name = source_to_copy
                                .file_name()
                                .unwrap()
                                .to_string_lossy()
                                .to_string();
                            (source_to_copy.clone(), name)
                        } else if let Some(correct_ext) = filetype::get_corrected_extension(&source_to_copy) {
                            // Rename the SOURCE file with correct extension in place
                            let stem = source_to_copy.file_stem().unwrap().to_string_lossy();
                            let corrected_name = format!("{}.{}", stem, correct_ext);
                            let corrected_path = source_to_copy.with_file_name(&corrected_name);
                            
                            match fs::rename(&source_to_copy, &corrected_path) {
                                Ok(_) => {
                                    corrected_count += 1;
                                    Logger::detail(&format!(
                                        "Corrected file type: {} -> {}",
                                        source_to_copy.display(), corrected_path.display()
                                    ));
                                    (corrected_path, corrected_name)
                                }
                                Err(e) => {
                                    Logger::warning(&format!(
                                        "Failed to rename file {}: {}. Using original.",
                                        source_to_copy.display(), e
                                    ));
                                    let name = source_to_copy
                                        .file_name()
                                        .unwrap()
                                        .to_string_lossy()
                                        .to_string();
                                    (source_to_copy.clone(), name)
                                }
                            }
                        } else {
                            let name = source_to_copy
                                .file_name()
                                .unwrap()
                                .to_string_lossy()
                                .to_string();
                            (source_to_copy.clone(), name)
                        }
                    } else {
                        // No extension - check if correction is needed
                        if let Some(correct_ext) = filetype::get_corrected_extension(&source_to_copy) {
                            // Rename the SOURCE file with correct extension in place
                            let stem = source_to_copy.file_stem().unwrap().to_string_lossy();
                            let corrected_name = format!("{}.{}", stem, correct_ext);
                            let corrected_path = source_to_copy.with_file_name(&corrected_name);
                            
                            match fs::rename(&source_to_copy, &corrected_path) {
                                Ok(_) => {
                                    corrected_count += 1;
                                    Logger::detail(&format!(
                                        "Corrected file type: {} -> {}",
                                        source_to_copy.display(), corrected_path.display()
                                    ));
                                    (corrected_path, corrected_name)
                                }
                                Err(e) => {
                                    Logger::warning(&format!(
                                        "Failed to rename file {}: {}. Using original.",
                                        source_to_copy.display(), e
                                    ));
                                    let name = source_to_copy
                                        .file_name()
                                        .unwrap()
                                        .to_string_lossy()
                                        .to_string();
                                    (source_to_copy.clone(), name)
                                }
                            }
                        } else {
                            let name = source_to_copy
                                .file_name()
                                .unwrap()
                                .to_string_lossy()
                                .to_string();
                            (source_to_copy.clone(), name)
                        }
                    };
                
                // Check if the corrected file is a valid image format
                // Only PNG, JPG, JPEG should remain as image links
                let corrected_ext = std::path::Path::new(&final_file_name)
                    .extension()
                    .and_then(|e| e.to_str())
                    .unwrap_or("");
                let is_valid_image = ["png", "jpg", "jpeg"]
                    .contains(&corrected_ext.to_lowercase().as_str());

                let dest_path = resources_dir.join(&final_file_name);

                // Verify source file exists and is a regular file
                if !source_to_use.exists() {
                    Logger::warning(&format!(
                        "Could not copy resource: Source file not found: {}",
                        source_to_use.display()
                    ));
                    continue;
                }

                // Check if it's a file or directory
                match std::fs::metadata(&source_to_use) {
                    Ok(metadata) => {
                        if metadata.is_dir() {
                            // It's a directory - recursively copy it
                            match copy_dir_recursively(&source_to_use, &dest_path) {
                                Ok(files_copied) => {
                                    copied_count += files_copied;
                                    // Update the link in markdown content
                                    let new_link = format!("{}_files/{}", base_name, final_file_name);
                                    updated_content = updated_content.replace(&link, &new_link);
                                }
                                Err(e) => {
                                    Logger::warning(&format!(
                                        "Could not copy directory: {} -> {}: {}",
                                        source_to_use.display(),
                                        dest_path.display(),
                                        e
                                    ));
                                }
                            }
                        } else if metadata.is_file() {
                            // Regular file - copy it
                            match std::fs::copy(&source_to_use, &dest_path) {
                                Ok(_) => {
                                    copied_count += 1;
                                    // Update the link in markdown content
                                    let new_link = format!("{}_files/{}", base_name, final_file_name);
                                    
                                    // Check if this was originally an image link
                                    let has_image_link = {
                                        let escaped_link = regex::escape(&link);
                                        let pattern = format!(r"!\[[^\]]*\]\({}\)", escaped_link);
                                        if let Ok(re) = regex::Regex::new(&pattern) {
                                            re.is_match(&updated_content)
                                        } else {
                                            false
                                        }
                                    };
                                    
                                    // If the file was corrected to a non-image format AND it was an image link,
                                    // convert image link to regular link
                                    if !is_valid_image && has_image_link {
                                        // Convert ![alt](old_link) to [alt](new_link)
                                        let escaped_link = regex::escape(&link);
                                        let re_str = format!(r"!\[([^\]]*)\]\({}\)", escaped_link);
                                        if let Ok(re) = regex::Regex::new(&re_str) {
                                            let replacement = format!("[$1]({})", new_link);
                                            updated_content = re.replace_all(&updated_content, replacement.as_str()).to_string();
                                        } else {
                                            // Fallback: just update the link path
                                            updated_content = updated_content.replace(&link, &new_link);
                                        }
                                    } else {
                                        // Keep the link type as-is, just update the path
                                        updated_content = updated_content.replace(&link, &new_link);
                                    }
                                }
                                Err(e) => {
                                    Logger::warning(&format!(
                                        "Could not copy resource: {} -> {}: {}",
                                        source_to_use.display(),
                                        dest_path.display(),
                                        e
                                    ));
                                }
                            }
                        } else {
                            Logger::warning(&format!(
                                "Could not copy resource: Not a regular file or directory: {}",
                                source_to_use.display()
                            ));
                        }
                    }
                    Err(e) => {
                        Logger::warning(&format!(
                            "Could not copy resource: Cannot read file metadata: {}: {}",
                            source_to_use.display(),
                            e
                        ));
                        continue;
                    }
                }
            }
        }
    }

    if copied_count > 0 {
        Logger::success(&format!(
            "Copied {} resource files to {}",
            copied_count,
            resources_dir.display()
        ));
        if corrected_count > 0 {
            Logger::info(&format!(
                "Corrected {} file extensions based on actual file type",
                corrected_count
            ));
        }
    }

    Ok(updated_content)
}

#[cfg(test)]
mod tests {
    use super::*;
    use tempfile::TempDir;

    #[test]
    fn test_process_directory_employee() {
        let temp_dir = TempDir::new().unwrap();
        let employee_dir = temp_dir.path().join("~testuser");
        let attachments_dir = employee_dir.join("attachments");
        fs::create_dir_all(&attachments_dir).unwrap();

        // Create index.html
        let index_html = r#"<html><body><h1>~testuser</h1><p>1</p><p>2</p></body></html>"#;
        fs::write(employee_dir.join("index.html"), index_html).unwrap();

        // Create homepage with Chinese name
        let homepage_html = r#"<html><body><h1>张三的主页</h1></body></html>"#;
        fs::write(employee_dir.join("张三的主页.html"), homepage_html).unwrap();

        // Create content page
        let page1_html = r#"<html><body><h1>Page 1</h1><p>Content</p></body></html>"#;
        fs::write(employee_dir.join("1.html"), page1_html).unwrap();

        // Create comment page with redirect
        let comment_html = r#"<html><head><meta http-equiv='refresh' content='0; url=1.html'></head><body><p>Comment text</p></body></html>"#;
        fs::write(employee_dir.join("2.html"), comment_html).unwrap();

        let result = process_directory(&employee_dir);
        assert!(result.is_some());

        let (alias, chinese_name, _file_count, markdown) = result.unwrap();
        assert_eq!(alias, "~testuser");
        assert_eq!(chinese_name, "张三");
        
        // Verify document has top-level title for PDF bookmarks
        assert!(markdown.contains("# ~testuser 张三\n"), 
            "Should have document title with alias and chinese name");
        
        // Verify page headers are level 2
        assert!(markdown.contains("## 1"));
        assert!(markdown.contains("Page 1"));
        assert!(markdown.contains("### Comment"));
        assert!(markdown.contains("Comment text"));
    }

    #[test]
    fn test_markdown_has_proper_header_hierarchy() {
        let temp_dir = TempDir::new().unwrap();
        let dir = temp_dir.path().join("~john-doe");
        fs::create_dir_all(&dir).unwrap();

        // Create index
        fs::write(dir.join("index.html"), "<html><body><p>1</p></body></html>").unwrap();

        // Create content pages
        fs::write(dir.join("page1.html"), "<html><body><h1>First Page</h1><p>Content 1</p></body></html>").unwrap();
        fs::write(dir.join("page2.html"), "<html><body><h1>Second Page</h1><p>Content 2</p></body></html>").unwrap();

        let result = process_directory(&dir);
        assert!(result.is_some());

        let (_alias, _chinese_name, _file_count, markdown) = result.unwrap();
        
        // Verify proper header hierarchy for PDF bookmarks
        // Level 1: Document title
        assert!(markdown.starts_with("# "), "Should start with level 1 header");
        
        // Level 2: Page titles
        assert!(markdown.contains("## page1"), "Should have level 2 headers for pages");
        assert!(markdown.contains("## page2"), "Should have level 2 headers for pages");
        
        // Verify H1 content is preserved as text, not as header
        assert!(markdown.contains("First Page"), "H1 content should be preserved");
        assert!(markdown.contains("Second Page"), "H1 content should be preserved");
    }

    #[test]
    fn test_project_directory_uses_project_name_as_title() {
        // Test that project directories (without Chinese name) use the directory name as title
        let temp_dir = TempDir::new().unwrap();
        let dir = temp_dir.path().join("MyProject-12345");
        fs::create_dir_all(&dir).unwrap();

        // Create index
        fs::write(dir.join("index.html"), "<html><body><p>1</p></body></html>").unwrap();

        // Create content pages without Chinese homepage
        fs::write(dir.join("1.html"), "<html><body><h1>Overview</h1><p>Project overview</p></body></html>").unwrap();
        fs::write(dir.join("2.html"), "<html><body><h1>Details</h1><p>Project details</p></body></html>").unwrap();

        let result = process_directory(&dir);
        assert!(result.is_some());

        let (alias, chinese_name, _file_count, markdown) = result.unwrap();
        
        // For project directory, alias and chinese_name should be the same (fallback)
        assert_eq!(alias, "MyProject-12345");
        assert_eq!(chinese_name, "MyProject-12345", "Should fallback to alias when no Chinese name");
        
        // Verify document title uses project name only (not duplicated)
        assert!(markdown.starts_with("# MyProject-12345\n"), 
            "Should use project name as title, got: {}", 
            markdown.lines().next().unwrap_or(""));
        
        // Should not duplicate the name
        assert!(!markdown.starts_with("# MyProject-12345 MyProject-12345"), 
            "Should not duplicate project name in title");
        
        // Verify page headers
        assert!(markdown.contains("## 1"), "Should have page headers");
        assert!(markdown.contains("## 2"), "Should have page headers");
    }

    #[test]
    fn test_process_directory_no_index() {
        let temp_dir = TempDir::new().unwrap();
        let test_dir = temp_dir.path().join("testdir");
        fs::create_dir_all(&test_dir).unwrap();

        let result = process_directory(&test_dir);
        assert!(result.is_none());
    }

    #[test]
    fn test_process_directory_with_attachments() {
        let temp_dir = TempDir::new().unwrap();
        let dir = temp_dir.path().join("~user");
        let attachments_dir = dir.join("attachments");
        fs::create_dir_all(&attachments_dir).unwrap();

        // Create index
        fs::write(dir.join("index.html"), "<html><body><p>1</p></body></html>").unwrap();

        // Create page
        fs::write(dir.join("1.html"), "<html><body>Page</body></html>").unwrap();

        // Create comment with redirect
        let comment = r#"<html><head><meta http-equiv='refresh' content='0; url=1.html'></head><body>Comment</body></html>"#;
        fs::write(dir.join("2.html"), comment).unwrap();

        // Create attachment for comment
        fs::write(attachments_dir.join("2_file.txt"), "content").unwrap();
        fs::write(attachments_dir.join("2_image.png"), "fake png").unwrap();

        let result = process_directory(&dir);
        assert!(result.is_some());

        let (_alias, _chinese_name, _count, markdown) = result.unwrap();
        assert!(markdown.contains("### Attachments"));
        assert!(markdown.contains("2_file.txt") || markdown.contains("2_image.png"));
    }

    #[test]
    fn test_process_directory_english_homepage() {
        let temp_dir = TempDir::new().unwrap();
        let dir = temp_dir.path().join("~johndoe");
        fs::create_dir_all(&dir).unwrap();

        // Create index
        fs::write(dir.join("index.html"), "<html><body><p>1</p></body></html>").unwrap();

        // Create English homepage
        fs::write(
            dir.join("John's Home.html"),
            "<html><body>Home</body></html>",
        )
        .unwrap();

        // Create page
        fs::write(dir.join("1.html"), "<html><body>Content</body></html>").unwrap();

        let result = process_directory(&dir);
        assert!(result.is_some());

        let (_alias, chinese_name, _count, _markdown) = result.unwrap();
        assert_eq!(chinese_name, "John");
    }

    #[test]
    fn test_process_directory_fallback_name() {
        let temp_dir = TempDir::new().unwrap();
        let dir = temp_dir.path().join("~noname");
        fs::create_dir_all(&dir).unwrap();

        // Create index without homepage file
        fs::write(dir.join("index.html"), "<html><body><p>1</p></body></html>").unwrap();
        fs::write(dir.join("1.html"), "<html><body>Page</body></html>").unwrap();

        let result = process_directory(&dir);
        assert!(result.is_some());

        let (_alias, chinese_name, _count, _markdown) = result.unwrap();
        // Should fallback to alias when no homepage found
        assert_eq!(chinese_name, "~noname");
    }

    #[test]
    fn test_extract_local_links() {
        let markdown = r#"
        ![Image](image.png)
        [Link](document.pdf)
        [External](http://example.com)
        ![Another Image](another_image.jpg)
        "#;

        let links = extract_local_links(markdown);
        assert_eq!(links.len(), 3);
        assert!(links.contains(&"image.png".to_string()));
        assert!(links.contains(&"document.pdf".to_string()));
        assert!(links.contains(&"another_image.jpg".to_string()));
    }

    #[test]
    fn test_is_external_url() {
        assert!(is_external_url("http://example.com"));
        assert!(is_external_url("https://example.com"));
        assert!(is_external_url("ftp://example.com"));
        assert!(is_external_url("mailto:example@example.com"));
        assert!(!is_external_url("image.png"));
        assert!(!is_external_url("document.pdf"));
    }

    #[test]
    fn test_resolve_link_to_path() {
        let temp_dir = TempDir::new().unwrap();
        let data_dir = temp_dir.path().to_path_buf();
        let alias_dir = data_dir.join("~user").join("attachments");
        fs::create_dir_all(&alias_dir).unwrap();

        // Create a test file in the alias directory
        let test_file = alias_dir.join("test_image.png");
        fs::write(&test_file, "test").unwrap();

        // Link should resolve to the test file
        let link = "~user/attachments/test_image.png";
        let resolved_path = resolve_link_to_path(link, &data_dir);
        assert!(resolved_path.is_some());
        assert_eq!(resolved_path.unwrap(), test_file);

        // External link should not resolve
        let external_link = "http://example.com/image.png";
        assert!(resolve_link_to_path(external_link, &data_dir).is_none());
    }

    #[test]
    fn test_copy_resources_and_update_links() {
        let temp_dir = TempDir::new().unwrap();
        let data_dir = temp_dir.path().to_path_buf();
        let output_md = temp_dir.path().join("output.md");
        let alias_dir = data_dir.join("~user").join("attachments");
        fs::create_dir_all(&alias_dir).unwrap();

        // Create test files with proper magic bytes
        let test_image = alias_dir.join("image.png");
        let test_doc = alias_dir.join("document.pdf");
        // Real PNG magic bytes
        fs::write(&test_image, &[0x89, 0x50, 0x4E, 0x47, 0x0D, 0x0A, 0x1A, 0x0A]).unwrap();
        // Real PDF magic bytes
        fs::write(&test_doc, b"%PDF-1.4").unwrap();

        let markdown_input = r#"
        ![Image](~user/attachments/image.png)
        [Document](~user/attachments/document.pdf)
        [External](http://example.com)
        "#;

        let updated_markdown =
            copy_resources_and_update_links(markdown_input, &output_md, &data_dir).unwrap();

        // Check that the resources directory was created
        let resources_dir = output_md.with_file_name("output_files");
        assert!(resources_dir.exists());

        // Check that the files were copied
        assert!(resources_dir.join("image.png").exists());
        assert!(resources_dir.join("document.pdf").exists());

        // Check that the links were updated in the markdown content
        assert!(updated_markdown.contains("![Image](output_files/image.png)"));
        assert!(updated_markdown.contains("[Document](output_files/document.pdf)"));
        // External URLs should remain unchanged
        assert!(updated_markdown.contains("[External](http://example.com)"));
    }

    #[test]
    fn test_process_directories_unified_valid() {
        let temp_dir = TempDir::new().unwrap();
        let data_dir = temp_dir.path().to_path_buf();
        let output_dir = temp_dir.path().join("output");
        fs::create_dir_all(&output_dir).unwrap();

        // Create a valid employee directory
        let employee_dir = data_dir.join("~testuser");
        fs::create_dir_all(&employee_dir).unwrap();

        // Create index.html with a homepage link
        fs::write(
            employee_dir.join("index.html"),
            "<html><body><p>1</p></body></html>",
        )
        .unwrap();

        // Create a homepage with Chinese name
        fs::write(
            employee_dir.join("TestUser's Home.html"),
            "<html><body><h1>主页</h1></body></html>",
        )
        .unwrap();

        // Create a page
        fs::write(
            employee_dir.join("1.html"),
            "<html><body><h1>Page 1</h1></body></html>",
        )
        .unwrap();

        // Process the directories
        process_directories_unified(&data_dir, Some(true), &output_dir);

        // Verify that the function completed successfully (either creates file or handles gracefully)
        // The main goal is to ensure no panics occur during processing
        assert!(output_dir.exists(), "Output directory should exist");
    }

    #[test]
    fn test_process_directories_unified_nonexistent_dir() {
        let temp_dir = TempDir::new().unwrap();
        let output_dir = temp_dir.path().join("output");
        fs::create_dir_all(&output_dir).unwrap();

        // Try to process a nonexistent directory
        let nonexistent_dir = temp_dir.path().join("nonexistent");
        process_directories_unified(&nonexistent_dir, Some(true), &output_dir);

        // Should handle gracefully without panic or error
        assert!(!output_dir.read_dir().unwrap().any(|e| {
            e.ok()
                .map(|f| f.path().extension().map(|ext| ext == "md").unwrap_or(false))
                .unwrap_or(false)
        }));
    }

    #[test]
    fn test_process_directories_unified_multiple_employees() {
        let temp_dir = TempDir::new().unwrap();
        let data_dir = temp_dir.path().to_path_buf();
        let output_dir = temp_dir.path().join("output");
        fs::create_dir_all(&output_dir).unwrap();

        // Create multiple employee directories
        for i in 1..=3 {
            let employee_dir = data_dir.join(format!("~user{}", i));
            fs::create_dir_all(&employee_dir).unwrap();
            fs::write(
                employee_dir.join("index.html"),
                "<html><body><p>1</p></body></html>",
            )
            .unwrap();
            fs::write(
                employee_dir.join(format!("User {}'s Home.html", i)),
                "<html><body><h1>主页</h1></body></html>",
            )
            .unwrap();
            fs::write(
                employee_dir.join("1.html"),
                format!("<html><body><h1>User {}</h1></body></html>", i),
            )
            .unwrap();
        }

        // Process the directories
        process_directories_unified(&data_dir, Some(true), &output_dir);

        // Verify markdown files were created (at least one should exist)
        let md_files: Vec<_> = output_dir
            .read_dir()
            .unwrap()
            .filter_map(|e| {
                e.ok().and_then(|f| {
                    if f.path().extension().map(|ext| ext == "md").unwrap_or(false) {
                        Some(f.path())
                    } else {
                        None
                    }
                })
            })
            .collect();

        assert!(
            md_files.len() >= 1,
            "At least one markdown file should be created"
        );
    }

    #[test]
    fn test_extract_local_links_various_formats() {
        let markdown = r#"
        ![Image 1](path/to/image1.png)
        [Link 1](document.pdf)
        ![Image 2](./another_image.jpg)
        [Link 2](../../relative/path/file.txt)
        [External](https://example.com)
        "#;

        let links = extract_local_links(markdown);
        assert!(links.contains(&"path/to/image1.png".to_string()));
        assert!(links.contains(&"document.pdf".to_string()));
        assert!(links.contains(&"./another_image.jpg".to_string()));
        assert!(links.contains(&"../../relative/path/file.txt".to_string()));
        assert!(!links.contains(&"https://example.com".to_string()));
    }

    #[test]
    fn test_is_external_url_schemes() {
        assert!(is_external_url("http://example.com"));
        assert!(is_external_url("https://example.com"));
        assert!(is_external_url("ftp://files.example.com"));
        assert!(is_external_url("mailto:user@example.com"));
        assert!(!is_external_url("ftps://secure.example.com")); // ftps is not in the supported list
        assert!(!is_external_url("data:text/plain;base64,SGVsbG8="));
    }

    #[test]
    fn test_convert_attachment_filenames_to_links_image() {
        let content =
            "This is a comment with 123456_attachments_image-2024-09-02_16-36-54.png in it.";
        let result = convert_attachment_filenames_to_links(content, "~user", "123456");

        assert!(result.contains("![123456_attachments_image-2024-09-02_16-36-54.png](~user/attachments/123456_attachments_image-2024-09-02_16-36-54.png)"));
    }

    #[test]
    fn test_convert_attachment_filenames_to_links_multiple() {
        let content =
            "Here are files: 123456_attachments_image.png and 123456_attachments_document.pdf";
        let result = convert_attachment_filenames_to_links(content, "~user", "123456");

        assert!(result.contains(
            "![123456_attachments_image.png](~user/attachments/123456_attachments_image.png)"
        ));
        assert!(result.contains(
            "[123456_attachments_document.pdf](~user/attachments/123456_attachments_document.pdf)"
        ));
    }

    #[test]
    fn test_convert_attachment_filenames_to_links_with_newlines() {
        let content =
            "Attachments:\n\n123456_attachments_image.png\n\n123456_attachments_data.json";
        let result = convert_attachment_filenames_to_links(content, "~user", "123456");

        assert!(result.contains(
            "![123456_attachments_image.png](~user/attachments/123456_attachments_image.png)"
        ));
        assert!(result.contains(
            "[123456_attachments_data.json](~user/attachments/123456_attachments_data.json)"
        ));
    }

    #[test]
    fn test_convert_attachment_filenames_to_links_no_match() {
        let content = "This content has no attachment filenames.";
        let result = convert_attachment_filenames_to_links(content, "~user", "123456");

        assert_eq!(result, content);
    }

    #[test]
    fn test_convert_attachment_filenames_to_links_different_comment_id() {
        let content = "Comment 123456_attachments_file.png should not match";
        let result = convert_attachment_filenames_to_links(content, "~user", "999999");

        // Should not be converted since comment_id doesn't match
        assert!(!result.contains("![]") && !result.contains("[]"));
        assert!(result.contains("123456_attachments_file.png"));
    }

    #[test]
    fn test_convert_attachment_filenames_to_links_various_image_formats() {
        let aliases = ["~user", "project"];
        let image_formats = vec!["png", "jpg", "jpeg", "gif", "bmp", "webp", "tiff", "svg"];

        for alias in aliases.iter() {
            for format in image_formats.iter() {
                let filename = format!("123456_attachments_image.{}", format);
                let content = format!("Here is: {}", filename);
                let result = convert_attachment_filenames_to_links(&content, alias, "123456");

                // Should be converted to image link
                assert!(
                    result.contains("![") && result.contains("]("),
                    "Failed for format {} with alias {}",
                    format,
                    alias
                );
            }
        }
    }

    #[test]
    fn test_convert_attachment_filenames_to_links_non_image_formats() {
        let content = "Files: 123456_attachments_document.pdf 123456_attachments_data.csv 123456_attachments_archive.zip";
        let result = convert_attachment_filenames_to_links(content, "~user", "123456");

        // All should be converted to regular links (not image links)
        // Verify PDF link
        assert!(result.contains(
            "[123456_attachments_document.pdf](~user/attachments/123456_attachments_document.pdf)"
        ));

        // Verify CSV link
        assert!(result.contains(
            "[123456_attachments_data.csv](~user/attachments/123456_attachments_data.csv)"
        ));

        // Verify ZIP link
        assert!(result.contains(
            "[123456_attachments_archive.zip](~user/attachments/123456_attachments_archive.zip)"
        ));
    }

    #[test]
    fn test_resolve_link_to_path_not_found() {
        let temp_dir = TempDir::new().unwrap();
        let data_dir = temp_dir.path().to_path_buf();

        // Create a directory structure
        let alias_dir = data_dir.join("~user").join("attachments");
        fs::create_dir_all(&alias_dir).unwrap();

        // Try to resolve a non-existent file
        let link = "~user/attachments/nonexistent.png";
        let resolved_path = resolve_link_to_path(link, &data_dir);
        assert!(resolved_path.is_none());
    }

    #[test]
    fn test_resolve_link_to_path_with_special_chars() {
        let temp_dir = TempDir::new().unwrap();
        let data_dir = temp_dir.path().to_path_buf();
        let alias_dir = data_dir.join("~user").join("attachments");
        fs::create_dir_all(&alias_dir).unwrap();

        // Create a test file with simple name
        let test_file = alias_dir.join("image.png");
        fs::write(&test_file, "test").unwrap();

        // Try to resolve using simple link
        let link = "~user/attachments/image.png";
        let resolved_path = resolve_link_to_path(link, &data_dir);
        assert!(resolved_path.is_some());
        assert_eq!(resolved_path.unwrap(), test_file);
    }

    #[test]
    fn test_copy_resources_no_links() {
        let temp_dir = TempDir::new().unwrap();
        let data_dir = temp_dir.path().to_path_buf();
        let output_md = temp_dir.path().join("output.md");

        let markdown_input = "# Title\n\nThis is a document with no links.";

        let updated_markdown =
            copy_resources_and_update_links(markdown_input, &output_md, &data_dir).unwrap();

        // Should return the same content
        assert_eq!(updated_markdown, markdown_input);
    }

    #[test]
    fn test_copy_resources_only_external_links() {
        let temp_dir = TempDir::new().unwrap();
        let data_dir = temp_dir.path().to_path_buf();
        let output_md = temp_dir.path().join("output.md");

        let markdown_input = r#"
        [Google](https://google.com)
        [Example](http://example.com)
        "#;

        let updated_markdown =
            copy_resources_and_update_links(markdown_input, &output_md, &data_dir).unwrap();

        // External links should remain unchanged
        assert!(updated_markdown.contains("[Google](https://google.com)"));
        assert!(updated_markdown.contains("[Example](http://example.com)"));

        // Resources directory should not be created
        let resources_dir = output_md.with_file_name("output_files");
        assert!(!resources_dir.exists());
    }

    #[test]
    fn test_process_directory_with_multiple_comments() {
        let temp_dir = TempDir::new().unwrap();
        let dir = temp_dir.path().join("~user");
        fs::create_dir_all(&dir).unwrap();

        // Create index
        fs::write(
            dir.join("index.html"),
            "<html><body><p>1</p><p>2</p><p>3</p></body></html>",
        )
        .unwrap();

        // Create pages for each link
        fs::write(
            dir.join("1.html"),
            "<html><body><h1>Page 1</h1></body></html>",
        )
        .unwrap();

        // Create comments with redirects
        let comment1 = r#"<html><head><meta http-equiv='refresh' content='0; url=1.html'></head><body>Comment 1</body></html>"#;
        fs::write(dir.join("2.html"), comment1).unwrap();

        let comment2 = r#"<html><head><meta http-equiv='refresh' content='0; url=1.html'></head><body>Comment 2</body></html>"#;
        fs::write(dir.join("3.html"), comment2).unwrap();

        let result = process_directory(&dir);
        assert!(result.is_some());

        let (_alias, _chinese_name, _count, markdown) = result.unwrap();
        assert!(markdown.contains("### Comment"));
        assert!(markdown.contains("Comment 1"));
        assert!(markdown.contains("Comment 2"));
    }

    #[test]
    fn test_process_directory_with_attachment_filenames_in_comments() {
        let temp_dir = TempDir::new().unwrap();
        let dir = temp_dir.path().join("~caoshanfeng");
        let attachments_dir = dir.join("attachments");
        fs::create_dir_all(&attachments_dir).unwrap();

        // Create index
        fs::write(dir.join("index.html"), "<html><body><p>1</p></body></html>").unwrap();

        // Create page with content
        fs::write(
            dir.join("1.html"),
            "<html><body><h1>Bond介绍</h1><p>Network bonding introduction</p></body></html>",
        )
        .unwrap();

        // Create comment with attachment filenames (like in Bond介绍.html)
        // This simulates the case where attachment filenames are listed as plain text
        let comment_html = r#"<html><head><meta http-equiv='refresh' content='0; url=1.html'></head><body>
            <p>Attachments</p>
            <p>143927134_attachments_image-2024-9-2_16-36-54.png</p>
            <p>143927134_attachments_image-2024-9-2_16-36-33.png</p>
            <p>143927134_attachments_1.json</p>
            <p>143927134_attachments_192.168.10.6.csv</p>
        </body></html>"#;
        fs::write(dir.join("143927134.html"), comment_html).unwrap();

        // Create actual attachment files
        fs::write(
            attachments_dir.join("143927134_attachments_image-2024-9-2_16-36-54.png"),
            "fake png",
        )
        .unwrap();
        fs::write(
            attachments_dir.join("143927134_attachments_image-2024-9-2_16-36-33.png"),
            "fake png",
        )
        .unwrap();
        fs::write(attachments_dir.join("143927134_attachments_1.json"), "{}").unwrap();
        fs::write(
            attachments_dir.join("143927134_attachments_192.168.10.6.csv"),
            "data",
        )
        .unwrap();

        let result = process_directory(&dir);
        assert!(result.is_some());

        let (_alias, _chinese_name, _count, markdown) = result.unwrap();

        // Verify that attachment filenames are converted to markdown links
        assert!(markdown.contains("![143927134_attachments_image-2024-9-2_16-36-54.png](~caoshanfeng/attachments/143927134_attachments_image-2024-9-2_16-36-54.png)"),
            "Image attachment should be converted to markdown image link");

        assert!(markdown.contains("![143927134_attachments_image-2024-9-2_16-36-33.png](~caoshanfeng/attachments/143927134_attachments_image-2024-9-2_16-36-33.png)"),
            "Second image attachment should be converted to markdown image link");

        assert!(markdown.contains("[143927134_attachments_1.json](~caoshanfeng/attachments/143927134_attachments_1.json)"),
            "JSON file should be converted to markdown link");

        assert!(markdown.contains("[143927134_attachments_192.168.10.6.csv](~caoshanfeng/attachments/143927134_attachments_192.168.10.6.csv)"),
            "CSV file should be converted to markdown link");

        // Verify that Comment header exists (indicating comment was processed)
        assert!(
            markdown.contains("### Comment"),
            "Comment header should be present"
        );

        // Make sure the filenames are no longer just plain text
        // (they should be inside markdown link syntax now)
        let lines_with_bare_filenames: Vec<&str> = markdown
            .lines()
            .filter(|line| {
                line.contains("143927134_attachments_")
                    && !line.contains("](")
                    && !line.contains("![")
            })
            .collect();

        assert!(
            lines_with_bare_filenames.is_empty(),
            "Attachment filenames should not appear as bare text, they should be markdown links"
        );
    }

    #[test]
    fn test_process_directory_attachment_filenames_in_page_content() {
        let temp_dir = TempDir::new().unwrap();
        let dir = temp_dir.path().join("~testuser");
        let attachments_dir = dir.join("attachments");
        fs::create_dir_all(&attachments_dir).unwrap();

        // Create index
        fs::write(
            dir.join("index.html"),
            "<html><body><p>1</p><p>999999</p></body></html>",
        )
        .unwrap();

        // Create page with attachment filenames listed in its content
        let page_html = r#"<html><body>
            <h1>Test Page</h1>
            <p>Configuration files:</p>
            <p>999999_attachments_config.txt</p>
            <p>999999_attachments_settings.json</p>
            <p>Some other content</p>
        </body></html>"#;
        fs::write(dir.join("1.html"), page_html).unwrap();

        // Create comment that redirects to the page
        let comment_html = r#"<html><head><meta http-equiv='refresh' content='0; url=1.html'></head><body>Comment</body></html>"#;
        fs::write(dir.join("999999.html"), comment_html).unwrap();

        // Create actual attachment files
        fs::write(
            attachments_dir.join("999999_attachments_config.txt"),
            "config",
        )
        .unwrap();
        fs::write(
            attachments_dir.join("999999_attachments_settings.json"),
            "{}",
        )
        .unwrap();

        let result = process_directory(&dir);
        assert!(result.is_some());

        let (_alias, _chinese_name, _count, markdown) = result.unwrap();

        // Page content attachment filenames are NOT converted to links in page content
        // (to avoid nested links issues). Instead, they appear as plain text in the page,
        // and the actual attachment links appear in the ### Attachments section.
        // So we verify that the attachments appear in the Attachments section instead.
        assert!(
            markdown.contains("### Attachments"),
            "Attachments section should be present"
        );

        // The actual attachment links should be in the Attachments section
        // (links will point to the _files directory after resource copying)
        assert!(
            markdown.contains("999999_attachments_config.txt") || markdown.contains("config.txt"),
            "Attachment should be referenced somewhere in the markdown"
        );
    }

    #[test]
    fn test_extract_image_urls_from_html() {
        let html = r#"<html><body>
            <img src="image1.png" alt="First image" />
            <img src="path/to/image2.jpg" />
            <img src="https://external.com/image3.gif" />
            <p>Some text</p>
            <img src="local_image4.svg" />
        </body></html>"#;

        let urls = extract_image_urls_from_html(html);

        assert_eq!(urls.len(), 4);
        assert_eq!(urls[0], (0, "image1.png".to_string()));
        assert_eq!(urls[1], (1, "path/to/image2.jpg".to_string()));
        assert_eq!(urls[2], (2, "https://external.com/image3.gif".to_string()));
        assert_eq!(urls[3], (3, "local_image4.svg".to_string()));
    }

    #[test]
    fn test_restore_image_urls_in_markdown() {
        let markdown = r#"Some text here

![](image_0.png)

More text

![alt text](image_1.jpg)

Final text"#;

        let original_urls = vec![
            (0, "attachments/photo_2024-01-15.png".to_string()),
            (1, "attachments/screenshot_2024-01-16.jpg".to_string()),
        ];

        let result = restore_image_urls_in_markdown(markdown, &original_urls);

        // Should replace generic names with original filenames
        assert!(result.contains("![](photo_2024-01-15.png)"));
        assert!(result.contains("![alt text](screenshot_2024-01-16.jpg)"));
        assert!(!result.contains("image_0.png"));
        assert!(!result.contains("image_1.jpg"));
    }

    #[test]
    fn test_restore_image_urls_preserves_alt_text() {
        let markdown = r#"![Custom alt text](image_0.png)
![Another description](image_1.gif)"#;

        let original_urls = vec![
            (0, "real_image_1.png".to_string()),
            (1, "real_image_2.gif".to_string()),
        ];

        let result = restore_image_urls_in_markdown(markdown, &original_urls);

        // Alt text should be preserved
        assert!(result.contains("![Custom alt text](real_image_1.png)"));
        assert!(result.contains("![Another description](real_image_2.gif)"));
    }

    #[test]
    fn test_extract_image_urls_empty_html() {
        let html = "<html><body><p>No images here</p></body></html>";
        let urls = extract_image_urls_from_html(html);
        assert_eq!(urls.len(), 0);
    }

    #[test]
    fn test_replace_generic_image_names_with_attachments() {
        let markdown = r#"Some content

![](image_0.png)

More text

![alt](image_1.jpg)

End"#;

        let temp_dir = TempDir::new().unwrap();
        let attach1 = temp_dir.path().join("photo_2024.png");
        let attach2 = temp_dir.path().join("screenshot.jpg");
        fs::write(&attach1, "png data").unwrap();
        fs::write(&attach2, "jpg data").unwrap();

        let attachments = vec![attach1, attach2];
        let result = map_generic_images_to_corrected_attachments(markdown, &attachments);

        // Should replace generic names with actual filenames
        assert!(result.contains("![](photo_2024.png)"));
        assert!(result.contains("![alt](screenshot.jpg)"));
        assert!(!result.contains("image_0.png"));
        assert!(!result.contains("image_1.jpg"));
    }

    #[test]
    fn test_replace_generic_image_names_empty_attachments() {
        let markdown = "![](image_0.png)";
        let attachments: Vec<PathBuf> = Vec::new();
        let result = map_generic_images_to_corrected_attachments(markdown, &attachments);

        // Should remain unchanged if no attachments provided
        assert_eq!(result, markdown);
    }

    #[test]
    fn test_clean_excessive_backticks() {
        let markdown = "Normal line\n\
                       `single backtick is ok`\n\
                       ``two backticks should be removed\n\
                       `````````````````````````````````\n\
                       Another normal line\n\
                       Code: `var x = 1` is fine";

        let result = clean_excessive_backticks(markdown);

        assert!(result.contains("Normal line"));
        assert!(result.contains("`single backtick is ok`"));
        assert!(result.contains("Another normal line"));
        assert!(result.contains("Code: `var x = 1` is fine"));
        assert!(!result.contains("``two backticks"));
        assert!(!result.contains("`````````````````````````````````"));
    }
    
    #[test]
    fn test_verify_image_format_converts_zip_to_regular_link() {
        use std::io::Write;
        
        // Create temp directory
        let temp_dir = TempDir::new().unwrap();
        
        // Step 1: Create a test.zip file
        let zip_path = temp_dir.path().join("test.zip");
        let mut zip_file = fs::File::create(&zip_path).unwrap();
        // Write ZIP magic bytes (PK\x03\x04)
        zip_file.write_all(&[0x50, 0x4B, 0x03, 0x04]).unwrap();
        drop(zip_file);
        
        // Step 2: Rename test.zip to test.png
        let png_path = temp_dir.path().join("test.png");
        fs::rename(&zip_path, &png_path).unwrap();
        
        // Step 3: Create test.html with the image link
        let html_content = r#"<html><body><img src="test.png" alt="test image"/></body></html>"#;
        let html_path = temp_dir.path().join("test.html");
        fs::write(&html_path, html_content).unwrap();
        
        // Step 4: Convert HTML to markdown (simulating what html2md does)
        let markdown_with_image_link = "![test image](test.png)";
        
        // Step 5: Run verify_and_fix_image_formats
        let result = verify_and_fix_image_formats(markdown_with_image_link, temp_dir.path());
        
        // Step 6: Verify the image link is updated to regular link with correct format
        // Should be [test image](test.zip) since the file is actually a ZIP
        assert!(result.contains("[test image](test.zip)"), 
            "Expected '[test image](test.zip)', got: {}", result);
        assert!(!result.contains("![test image](test.png)"), 
            "Should not contain image link anymore");
    }

    #[test]
    fn test_verify_image_format_converts_json_to_regular_link() {
        use std::io::Write;
        
        // Create temp directory with attachments subdirectory
        let temp_dir = TempDir::new().unwrap();
        let attachments_dir = temp_dir.path().join("attachments");
        fs::create_dir_all(&attachments_dir).unwrap();
        
        // Create JSON file named as PNG
        let json_path = attachments_dir.join("129101971_attachments_image-2024-7-11_10-15-52.png");
        let mut json_file = fs::File::create(&json_path).unwrap();
        json_file.write_all(b"{\"key\": \"value\", \"data\": 123}").unwrap();
        drop(json_file);
        
        // Create markdown with image link
        let markdown = "![diagram](129101971_attachments_image-2024-7-11_10-15-52.png)";
        
        // Run verification
        let result = verify_and_fix_image_formats(markdown, temp_dir.path());
        
        // Should convert to regular link with .json extension
        assert!(
            result.contains("[diagram](129101971_attachments_image-2024-7-11_10-15-52.json)"),
            "Expected regular link with .json extension, got: {}", result
        );
        assert!(
            !result.contains("!["),
            "Should not contain image link marker"
        );
    }

    #[test]
    fn test_verify_image_format_keeps_real_png_as_image() {
        use std::io::Write;
        
        // Create temp directory with attachments subdirectory
        let temp_dir = TempDir::new().unwrap();
        let attachments_dir = temp_dir.path().join("attachments");
        fs::create_dir_all(&attachments_dir).unwrap();
        
        // Create real PNG file (PNG magic bytes: \x89PNG\r\n\x1a\n)
        let png_path = attachments_dir.join("real_image.png");
        let mut png_file = fs::File::create(&png_path).unwrap();
        png_file.write_all(&[0x89, 0x50, 0x4E, 0x47, 0x0D, 0x0A, 0x1A, 0x0A]).unwrap();
        drop(png_file);
        
        // Create markdown with image link
        let markdown = "![real image](real_image.png)";
        
        // Run verification
        let result = verify_and_fix_image_formats(markdown, temp_dir.path());
        
        // Should keep as image link since it's a real PNG
        assert!(
            result.contains("![real image](real_image.png)"),
            "Real PNG should remain as image link, got: {}", result
        );
    }

    #[test]
    fn test_verify_image_format_handles_multiple_files() {
        use std::io::Write;
        
        // Create temp directory with attachments subdirectory
        let temp_dir = TempDir::new().unwrap();
        let attachments_dir = temp_dir.path().join("attachments");
        fs::create_dir_all(&attachments_dir).unwrap();
        
        // Create JSON file named as PNG
        let json_path = attachments_dir.join("file1.png");
        let mut json_file = fs::File::create(&json_path).unwrap();
        // Use longer JSON content to trigger detection (needs >= 20 bytes)
        json_file.write_all(b"{\"key\": \"value\", \"data\": 123}").unwrap();
        drop(json_file);
        
        // Create real PNG
        let png_path = attachments_dir.join("file2.png");
        let mut png_file = fs::File::create(&png_path).unwrap();
        png_file.write_all(&[0x89, 0x50, 0x4E, 0x47, 0x0D, 0x0A, 0x1A, 0x0A]).unwrap();
        drop(png_file);
        
        // Create ZIP named as PNG
        let zip_path = attachments_dir.join("file3.png");
        let mut zip_file = fs::File::create(&zip_path).unwrap();
        zip_file.write_all(&[0x50, 0x4B, 0x03, 0x04]).unwrap();
        drop(zip_file);
        
        // Create markdown with multiple image links
        let markdown = r#"# Document

![json file](file1.png)

Some text here.

![real png](file2.png)

More text.

![zip file](file3.png)
"#;
        
        // Run verification
        let result = verify_and_fix_image_formats(markdown, temp_dir.path());
        
        // JSON should be converted to regular link
        assert!(
            result.contains("[json file](file1.json)"),
            "JSON file should be converted to regular link, got: {}", result
        );
        assert!(
            !result.contains("![json file]"),
            "JSON file should not have image marker"
        );
        
        // Real PNG should remain as image
        assert!(
            result.contains("![real png](file2.png)"),
            "Real PNG should remain as image link"
        );
        
        // ZIP should be converted to regular link
        assert!(
            result.contains("[zip file](file3.zip)"),
            "ZIP file should be converted to regular link"
        );
        assert!(
            !result.contains("![zip file]"),
            "ZIP file should not have image marker"
        );
    }

    #[test]
    fn test_attachment_links_use_filename_only() {
        // This test verifies the fix for the issue where markdown links used
        // {alias}/attachments/{filename} format, but files were copied to
        // {output_basename}_files/{filename}, causing "Referenced image not found" errors
        
        let temp_dir = TempDir::new().unwrap();
        let dir = temp_dir.path().join("NEZ");
        let attachments_dir = dir.join("attachments");
        fs::create_dir_all(&attachments_dir).unwrap();

        // Create index
        fs::write(dir.join("index.html"), "<html><body><p>1</p></body></html>").unwrap();

        // Create page
        fs::write(dir.join("1.html"), "<html><body>Content</body></html>").unwrap();

        // Create comment with redirect
        let comment = r#"<html><head><meta http-equiv='refresh' content='0; url=1.html'></head><body>Comment</body></html>"#;
        fs::write(dir.join("2.html"), comment).unwrap();

        // Create attachment with Chinese characters and parentheses
        fs::write(
            attachments_dir.join("2_attachments_未命名文件(6).png"),
            "fake png",
        )
        .unwrap();

        let result = process_directory(&dir);
        assert!(result.is_some());

        let (_alias, _chinese_name, _count, markdown) = result.unwrap();
        
        // The markdown should contain just the filename, not {alias}/attachments/{filename}
        // This allows copy_resources_and_update_links to resolve the path correctly
        assert!(
            markdown.contains("2_attachments_未命名文件(6).png"),
            "Markdown should contain the attachment filename"
        );
        
        // Should NOT contain the old format with alias/attachments
        assert!(
            !markdown.contains("NEZ/attachments/2_attachments_未命名文件(6).png"),
            "Markdown should not contain alias/attachments path format"
        );
        
        // Verify it's in image format (starts with !)
        assert!(
            markdown.contains("![") && markdown.contains("](2_attachments_未命名文件(6).png)"),
            "Markdown should contain image link with just filename"
        );
    }

    #[test]
    fn test_copy_resources_resolves_filename_only_links() {
        // Test that copy_resources_and_update_links correctly resolves
        // links that are just filenames (no directory path)
        
        let temp_dir = TempDir::new().unwrap();
        
        // Setup: Create source directory with attachments
        let source_dir = temp_dir.path().join("source");
        let attachments_dir = source_dir.join("attachments");
        fs::create_dir_all(&attachments_dir).unwrap();
        
        // Create test image file
        fs::write(attachments_dir.join("test_image.png"), "fake png content").unwrap();
        
        // Create markdown with just filename (no path)
        let markdown = "# Test\n\n![test image](test_image.png)\n";
        
        // Setup: Create output path (will be something like "output-123.md")
        let output_path = temp_dir.path().join("output.md");
        
        // Execute: Copy resources and update links
        let result = copy_resources_and_update_links(markdown, &output_path, &source_dir);
        
        assert!(result.is_ok(), "copy_resources_and_update_links should succeed");
        
        let updated_markdown = result.unwrap();
        
        // Verify: Link should be updated to {basename}_files/{filename}
        assert!(
            updated_markdown.contains("output_files/test_image.png"),
            "Link should be updated to output_files/test_image.png, got: {}",
            updated_markdown
        );
        
        // Verify: File should be copied to output_files directory
        let copied_file = temp_dir.path().join("output_files").join("test_image.png");
        assert!(
            copied_file.exists(),
            "File should be copied to output_files directory"
        );
    }

    #[test]
    fn test_attachment_links_with_parentheses_in_filename() {
        // Test that attachments with parentheses in filename work correctly
        // This combines the parentheses regex fix with the path resolution fix
        
        let temp_dir = TempDir::new().unwrap();
        let dir = temp_dir.path().join("PROJECT");
        let attachments_dir = dir.join("attachments");
        fs::create_dir_all(&attachments_dir).unwrap();

        // Create index
        fs::write(dir.join("index.html"), "<html><body><p>1</p></body></html>").unwrap();
        
        // Create page
        fs::write(dir.join("1.html"), "<html><body>Content</body></html>").unwrap();
        
        // Create comment
        let comment = r#"<html><head><meta http-equiv='refresh' content='0; url=1.html'></head><body>Comment</body></html>"#;
        fs::write(dir.join("2.html"), comment).unwrap();
        
        // Create attachments with parentheses
        fs::write(attachments_dir.join("2_file(1).txt"), "content").unwrap();
        fs::write(attachments_dir.join("2_image(copy)(2).png"), "fake png").unwrap();

        let result = process_directory(&dir);
        assert!(result.is_some());

        let (_alias, _chinese_name, _count, markdown) = result.unwrap();
        
        // Both filenames with parentheses should be present
        assert!(
            markdown.contains("2_file(1).txt"),
            "Should contain file with single parenthesis"
        );
        assert!(
            markdown.contains("2_image(copy)(2).png"),
            "Should contain file with multiple parentheses"
        );
        
        // Should be in correct format (filename only, not full path)
        assert!(
            markdown.contains("](2_file(1).txt)") || markdown.contains("(2_file(1).txt)"),
            "File link should use filename only"
        );
        assert!(
            markdown.contains("](2_image(copy)(2).png)"),
            "Image link should use filename only"
        );
    }

    #[test]
    fn test_mixed_attachment_types_all_use_filename_only() {
        // Test that both image and non-image attachments use filename-only format
        
        let temp_dir = TempDir::new().unwrap();
        let dir = temp_dir.path().join("MIXED");
        let attachments_dir = dir.join("attachments");
        fs::create_dir_all(&attachments_dir).unwrap();

        // Create index
        fs::write(dir.join("index.html"), "<html><body><p>1</p></body></html>").unwrap();
        
        // Create page
        fs::write(dir.join("1.html"), "<html><body>Content</body></html>").unwrap();
        
        // Create comment
        let comment = r#"<html><head><meta http-equiv='refresh' content='0; url=1.html'></head><body>Comment</body></html>"#;
        fs::write(dir.join("2.html"), comment).unwrap();
        
        // Create various attachment types
        fs::write(attachments_dir.join("2_image.png"), "fake png").unwrap();
        fs::write(attachments_dir.join("2_doc.pdf"), "fake pdf").unwrap();
        fs::write(attachments_dir.join("2_archive.zip"), "fake zip").unwrap();
        fs::write(attachments_dir.join("2_text.txt"), "text content").unwrap();

        let result = process_directory(&dir);
        assert!(result.is_some());

        let (_alias, _chinese_name, _count, markdown) = result.unwrap();
        
        // All attachment types should use filename-only format
        let attachments = vec!["2_image.png", "2_doc.pdf", "2_archive.zip", "2_text.txt"];
        
        for attachment in attachments {
            assert!(
                markdown.contains(attachment),
                "Markdown should contain {}", attachment
            );
            
            // Should NOT contain old path format
            assert!(
                !markdown.contains(&format!("MIXED/attachments/{}", attachment)),
                "Should not use old MIXED/attachments/ format for {}", attachment
            );
        }
    }

    #[test]
    fn test_resolve_link_from_sibling_files_directory() {
        // Test that resolve_link_to_path can find files in sibling _files directories
        // Example: data_dir is "NEZ/" and file is in sibling "NEZ-3359_files/"
        
        let temp_dir = TempDir::new().unwrap();
        let parent = temp_dir.path();
        
        // Create NEZ directory (source directory)
        let nez_dir = parent.join("NEZ");
        fs::create_dir_all(&nez_dir).unwrap();
        
        // Create NEZ-3359_files directory (sibling directory with resources)
        let files_dir = parent.join("NEZ-3359_files");
        fs::create_dir_all(&files_dir).unwrap();
        
        // Create test file in the _files directory
        fs::write(files_dir.join("test_image.png"), "fake png").unwrap();
        
        // Test: resolve_link_to_path should find the file in sibling directory
        let resolved = resolve_link_to_path("test_image.png", &nez_dir);
        
        assert!(resolved.is_some(), "Should resolve file from sibling _files directory");
        
        let resolved_path = resolved.unwrap();
        assert!(resolved_path.exists(), "Resolved path should exist");
        assert_eq!(
            resolved_path.file_name().unwrap().to_string_lossy(),
            "test_image.png",
            "Resolved path should point to correct file"
        );
        assert!(
            resolved_path.to_string_lossy().contains("NEZ-3359_files"),
            "Resolved path should be in NEZ-3359_files directory, got: {}",
            resolved_path.display()
        );
    }

    #[test]
    fn test_resolve_link_with_parentheses_from_sibling_files() {
        // Test that files with parentheses in names can be resolved from sibling _files directories
        
        let temp_dir = TempDir::new().unwrap();
        let parent = temp_dir.path();
        
        // Create source directory
        let source_dir = parent.join("PROJECT");
        fs::create_dir_all(&source_dir).unwrap();
        
        // Create sibling _files directory
        let files_dir = parent.join("PROJECT-5678_files");
        fs::create_dir_all(&files_dir).unwrap();
        
        // Create files with parentheses
        fs::write(files_dir.join("image(1).png"), "fake png").unwrap();
        fs::write(files_dir.join("file(copy)(2).txt"), "text").unwrap();
        
        // Test: Both files should be resolvable
        let resolved1 = resolve_link_to_path("image(1).png", &source_dir);
        assert!(resolved1.is_some(), "Should resolve image(1).png from sibling directory");
        assert!(resolved1.unwrap().exists());
        
        let resolved2 = resolve_link_to_path("file(copy)(2).txt", &source_dir);
        assert!(resolved2.is_some(), "Should resolve file(copy)(2).txt from sibling directory");
        assert!(resolved2.unwrap().exists());
    }

    #[test]
    fn test_copy_resources_from_sibling_files_directory() {
        // Integration test: copy_resources_and_update_links should work with sibling _files directories
        
        let temp_dir = TempDir::new().unwrap();
        let parent = temp_dir.path();
        
        // Setup: Create source directory
        let source_dir = parent.join("NEZ");
        fs::create_dir_all(&source_dir).unwrap();
        
        // Setup: Create sibling _files directory with resources
        let files_dir = parent.join("NEZ-3359_files");
        fs::create_dir_all(&files_dir).unwrap();
        fs::write(files_dir.join("14820447_attachments_1622788615(1).png"), "fake png").unwrap();
        fs::write(files_dir.join("14820447_attachments_1622788939(1).png"), "fake png 2").unwrap();
        
        // Create markdown with filename-only links
        let markdown = r#"# Test Document

![Image 1](14820447_attachments_1622788615(1).png)

Some text here.

![Image 2](14820447_attachments_1622788939(1).png)
"#;
        
        // Create output path
        let output_path = parent.join("output").join("NEZ-3359.md");
        
        // Execute: Copy resources and update links
        let result = copy_resources_and_update_links(markdown, &output_path, &source_dir);
        
        assert!(result.is_ok(), "Should successfully copy resources from sibling directory");
        
        let updated_markdown = result.unwrap();
        
        // Verify: Links should be updated
        assert!(
            updated_markdown.contains("NEZ-3359_files/14820447_attachments_1622788615(1).png"),
            "Should update first image link, got: {}", updated_markdown
        );
        assert!(
            updated_markdown.contains("NEZ-3359_files/14820447_attachments_1622788939(1).png"),
            "Should update second image link, got: {}", updated_markdown
        );
        
        // Verify: Files should be copied
        let output_files_dir = parent.join("output").join("NEZ-3359_files");
        assert!(
            output_files_dir.join("14820447_attachments_1622788615(1).png").exists(),
            "First image should be copied"
        );
        assert!(
            output_files_dir.join("14820447_attachments_1622788939(1).png").exists(),
            "Second image should be copied"
        );
    }

    #[test]
    fn test_multiple_sibling_files_directories_prefer_matching_prefix() {
        // Test that when multiple _files directories exist, we prefer the one matching current dir name
        
        let temp_dir = TempDir::new().unwrap();
        let parent = temp_dir.path();
        
        // Create source directory
        let source_dir = parent.join("NEZ");
        fs::create_dir_all(&source_dir).unwrap();
        
        // Create multiple _files directories
        let files_dir1 = parent.join("OTHER-1234_files");
        fs::create_dir_all(&files_dir1).unwrap();
        fs::write(files_dir1.join("test.png"), "other").unwrap();
        
        let files_dir2 = parent.join("NEZ-3359_files");
        fs::create_dir_all(&files_dir2).unwrap();
        fs::write(files_dir2.join("test.png"), "correct").unwrap();
        
        // Test: Should find file in NEZ-3359_files (matches prefix), not OTHER-1234_files
        let resolved = resolve_link_to_path("test.png", &source_dir);
        
        assert!(resolved.is_some(), "Should resolve file");
        
        let resolved_path = resolved.unwrap();
        assert!(
            resolved_path.to_string_lossy().contains("NEZ-3359_files"),
            "Should resolve from NEZ-3359_files (matching prefix), got: {}",
            resolved_path.display()
        );
        
        // Verify it's the correct file
        let content = fs::read_to_string(&resolved_path).unwrap();
        assert_eq!(content, "correct", "Should find file from correct _files directory");
    }

    #[test]
    fn test_copy_resources_converts_json_to_regular_link() {
        use std::io::Write;
        
        // Test that when a .png file is actually JSON, it gets:
        // 1. Renamed to .json
        // 2. Image link ![...] converted to regular link [...]
        
        let temp_dir = TempDir::new().unwrap();
        let parent = temp_dir.path();
        
        // Setup: Create source directory with attachments
        let source_dir = parent.join("source");
        let attachments_dir = source_dir.join("attachments");
        fs::create_dir_all(&attachments_dir).unwrap();
        
        // Create JSON file named as PNG
        let json_path = attachments_dir.join("data.png");
        let mut json_file = fs::File::create(&json_path).unwrap();
        json_file.write_all(b"{\"key\": \"value\", \"data\": 123}").unwrap();
        drop(json_file);
        
        // Create markdown with image link
        let markdown = "# Test\n\n![my data](data.png)\n";
        
        // Create output path
        let output_path = parent.join("output.md");
        
        // Execute: Copy resources and update links
        let result = copy_resources_and_update_links(markdown, &output_path, &source_dir);
        
        assert!(result.is_ok(), "Should successfully process JSON file");
        
        let updated_markdown = result.unwrap();
        
        // Verify: Should be a regular link (not image) with .json extension
        assert!(
            updated_markdown.contains("[my data](output_files/data.json)"),
            "Should convert to regular link with .json extension, got: {}", updated_markdown
        );
        assert!(
            !updated_markdown.contains("![my data]"),
            "Should not have image link marker"
        );
        
        // Verify: File should be copied with .json extension
        let copied_file = parent.join("output_files").join("data.json");
        assert!(
            copied_file.exists(),
            "File should be copied with .json extension"
        );
    }

    #[test]
    fn test_copy_resources_keeps_real_png_as_image() {
        use std::io::Write;
        
        // Test that real PNG files stay as image links
        
        let temp_dir = TempDir::new().unwrap();
        let parent = temp_dir.path();
        
        // Setup: Create source directory with attachments
        let source_dir = parent.join("source");
        let attachments_dir = source_dir.join("attachments");
        fs::create_dir_all(&attachments_dir).unwrap();
        
        // Create real PNG file
        let png_path = attachments_dir.join("real.png");
        let mut png_file = fs::File::create(&png_path).unwrap();
        // PNG magic bytes
        png_file.write_all(&[0x89, 0x50, 0x4E, 0x47, 0x0D, 0x0A, 0x1A, 0x0A]).unwrap();
        drop(png_file);
        
        // Create markdown with image link
        let markdown = "# Test\n\n![my image](real.png)\n";
        
        // Create output path
        let output_path = parent.join("output.md");
        
        // Execute: Copy resources and update links
        let result = copy_resources_and_update_links(markdown, &output_path, &source_dir);
        
        assert!(result.is_ok(), "Should successfully process PNG file");
        
        let updated_markdown = result.unwrap();
        
        // Verify: Should remain as image link
        assert!(
            updated_markdown.contains("![my image](output_files/real.png)"),
            "Should keep as image link, got: {}", updated_markdown
        );
    }

    #[test]
    fn test_real_world_scenario_nez_directory_structure() {
        // Full integration test simulating real user scenario:
        // Output: NEZ-3359.md with NEZ-3359_files/
        
        let temp_dir = TempDir::new().unwrap();
        let project_root = temp_dir.path().join("g-project");
        let output_dir = project_root.join("output");
        fs::create_dir_all(&output_dir).unwrap();
        
        // Create NEZ source directory with HTML and attachments
        let nez_dir = project_root.join("NEZ");
        let attachments_dir = nez_dir.join("attachments");
        fs::create_dir_all(&attachments_dir).unwrap();
        
        // Create HTML files
        fs::write(nez_dir.join("index.html"), 
            "<html><body><p>1</p></body></html>").unwrap();
        fs::write(nez_dir.join("1.html"), 
            "<html><body>Main content</body></html>").unwrap();
        
        // Create comment that references the main page
        let comment_html = r#"<html>
            <head><meta http-equiv='refresh' content='0; url=1.html'></head>
            <body>Comment content</body>
        </html>"#;
        fs::write(nez_dir.join("14820447.html"), comment_html).unwrap();
        
        // Create attachment files with parentheses (real-world case)
        fs::write(
            attachments_dir.join("14820447_attachments_1622788615(1).png"),
            "fake png content 1"
        ).unwrap();
        fs::write(
            attachments_dir.join("14820447_attachments_1622788939(1).png"),
            "fake png content 2"
        ).unwrap();
        fs::write(
            attachments_dir.join("14820447_attachments_1622789232(1).png"),
            "fake png content 3"
        ).unwrap();
        
        // Step 1: Process directory to generate markdown
        let result = process_directory(&nez_dir);
        assert!(result.is_some(), "Should successfully process NEZ directory");
        
        let (alias, _chinese_name, file_count, markdown_content) = result.unwrap();
        assert_eq!(alias, "NEZ");
        
        // Step 2: Verify markdown contains the image filenames
        assert!(markdown_content.contains("14820447_attachments_1622788615(1).png"));
        assert!(markdown_content.contains("14820447_attachments_1622788939(1).png"));
        assert!(markdown_content.contains("14820447_attachments_1622789232(1).png"));
        
        // Step 3: Simulate writing output file and copying resources
        let output_filename = format!("NEZ-{}.md", file_count);
        let output_path = output_dir.join(&output_filename);
        
        // Step 4: Copy resources and update links (this is what the main process does)
        let updated_markdown = copy_resources_and_update_links(
            &markdown_content,
            &output_path,
            &nez_dir
        ).unwrap();
        
        // Step 5: Verify links were updated to point to _files directory
        let expected_files_dir = format!("NEZ-{}_files", file_count);
        assert!(
            updated_markdown.contains(&format!("{}/14820447_attachments_1622788615(1).png", expected_files_dir)),
            "Link should be updated to {}/..., got: {}", expected_files_dir, updated_markdown
        );
        assert!(
            updated_markdown.contains(&format!("{}/14820447_attachments_1622788939(1).png", expected_files_dir))
        );
        assert!(
            updated_markdown.contains(&format!("{}/14820447_attachments_1622789232(1).png", expected_files_dir))
        );
        
        // Step 6: Verify files were actually copied
        let files_dir = output_dir.join(&expected_files_dir);
        assert!(files_dir.exists(), "Files directory should be created");
        assert!(
            files_dir.join("14820447_attachments_1622788615(1).png").exists(),
            "First image should be copied"
        );
        assert!(
            files_dir.join("14820447_attachments_1622788939(1).png").exists(),
            "Second image should be copied"
        );
        assert!(
            files_dir.join("14820447_attachments_1622789232(1).png").exists(),
            "Third image should be copied"
        );
        
        // Step 7: Write the final markdown file
        fs::write(&output_path, updated_markdown).unwrap();
        
        // Step 8: Verify the markdown file can be read and has correct content
        let final_markdown = fs::read_to_string(&output_path).unwrap();
        assert!(final_markdown.contains(&expected_files_dir));
    }

    #[test]
    fn test_csv_file_type_correction_and_link_conversion() {
        use std::io::Write;
        
        // Test that CSV files misnamed as PNG get:
        // 1. Detected and renamed to .csv
        // 2. Image link ![...] converted to regular link [...]
        // 3. Updated markdown written with correct link
        
        let temp_dir = TempDir::new().unwrap();
        let parent = temp_dir.path();
        
        let source_dir = parent.join("source");
        let attachments_dir = source_dir.join("attachments");
        fs::create_dir_all(&attachments_dir).unwrap();
        
        // Create CSV file with .png extension
        let csv_path = attachments_dir.join("export_data.png");
        let mut csv_file = fs::File::create(&csv_path).unwrap();
        csv_file.write_all(b"Name,Age,City\nAlice,30,NYC\nBob,25,SF\n").unwrap();
        drop(csv_file);
        
        let markdown = "# Data Export\n\n![CSV Export](export_data.png)\n\nAbove is the data.";
        let output_path = parent.join("report.md");
        
        let result = copy_resources_and_update_links(markdown, &output_path, &source_dir);
        
        assert!(result.is_ok(), "Should successfully process CSV file");
        let updated_markdown = result.unwrap();
        
        // Verify: Should be regular link with .csv extension
        assert!(
            updated_markdown.contains("[CSV Export](report_files/export_data.csv)"),
            "Should convert image link to regular link with .csv extension, got: {}", updated_markdown
        );
        assert!(
            !updated_markdown.contains("![CSV Export]"),
            "Should not have image link marker"
        );
        
        // Verify: File should be copied with .csv extension
        let copied_file = parent.join("report_files").join("export_data.csv");
        assert!(
            copied_file.exists(),
            "File should be copied with .csv extension"
        );
        
        // Verify: File content is preserved
        let content = fs::read_to_string(copied_file).unwrap();
        assert!(content.contains("Name,Age,City"), "CSV content should be preserved");
    }

    #[test]
    fn test_eml_file_type_correction_and_link_conversion() {
        use std::io::Write;
        
        // Test that EML (email) files misnamed as PNG get:
        // 1. Detected and renamed to .eml
        // 2. Image link ![...] converted to regular link [...]
        // 3. Updated markdown written with correct link
        
        let temp_dir = TempDir::new().unwrap();
        let parent = temp_dir.path();
        
        let source_dir = parent.join("source");
        let attachments_dir = source_dir.join("attachments");
        fs::create_dir_all(&attachments_dir).unwrap();
        
        // Create EML file with .png extension
        let eml_path = attachments_dir.join("message.png");
        let mut eml_file = fs::File::create(&eml_path).unwrap();
        eml_file.write_all(b"From: sender@example.com\nTo: recipient@example.com\nSubject: Test\n\nHello World").unwrap();
        drop(eml_file);
        
        let markdown = "# Email Archive\n\nSee attached: ![Email Message](message.png)\n";
        let output_path = parent.join("archive.md");
        
        let result = copy_resources_and_update_links(markdown, &output_path, &source_dir);
        
        assert!(result.is_ok(), "Should successfully process EML file");
        let updated_markdown = result.unwrap();
        
        // Verify: Should be regular link with .eml extension
        assert!(
            updated_markdown.contains("[Email Message](archive_files/message.eml)"),
            "Should convert image link to regular link with .eml extension, got: {}", updated_markdown
        );
        assert!(
            !updated_markdown.contains("![Email Message]"),
            "Should not have image link marker"
        );
        
        // Verify: File should be copied with .eml extension
        let copied_file = parent.join("archive_files").join("message.eml");
        assert!(
            copied_file.exists(),
            "File should be copied with .eml extension"
        );
    }

    #[test]
    fn test_multiple_file_type_corrections_in_one_document() {
        use std::io::Write;
        
        // Test that multiple files with different corrections are all updated correctly
        
        let temp_dir = TempDir::new().unwrap();
        let parent = temp_dir.path();
        
        let source_dir = parent.join("source");
        let attachments_dir = source_dir.join("attachments");
        fs::create_dir_all(&attachments_dir).unwrap();
        
        // Create JSON file as .png
        let json_path = attachments_dir.join("config.png");
        let mut json_file = fs::File::create(&json_path).unwrap();
        json_file.write_all(b"{\"setting\": true, \"enabled\": false}").unwrap();
        drop(json_file);
        
        // Create CSV file with .png extension
        let csv_path = attachments_dir.join("data.png");
        let mut csv_file = fs::File::create(&csv_path).unwrap();
        csv_file.write_all(b"A,B,C\n1,2,3\n4,5,6\n7,8,9\n").unwrap();
        drop(csv_file);
        
        // Create real PNG
        let real_png_path = attachments_dir.join("logo.png");
        let mut png_file = fs::File::create(&real_png_path).unwrap();
        png_file.write_all(&[0x89, 0x50, 0x4E, 0x47, 0x0D, 0x0A, 0x1A, 0x0A]).unwrap();
        drop(png_file);
        
        // Create EML file as .png
        let eml_path = attachments_dir.join("email.png");
        let mut eml_file = fs::File::create(&eml_path).unwrap();
        eml_file.write_all(b"From: test@example.com\nSubject: Test\n\nBody").unwrap();
        drop(eml_file);
        
        let markdown = r#"# Mixed Content

![Config](config.png)

![Data](data.png)

![Logo](logo.png)

![Email](email.png)
"#;
        
        let output_path = parent.join("mixed.md");
        let result = copy_resources_and_update_links(markdown, &output_path, &source_dir);
        
        assert!(result.is_ok(), "Should successfully process all files");
        let updated_markdown = result.unwrap();
        
        // Verify: JSON converted to regular link with .json
        assert!(
            updated_markdown.contains("[Config](mixed_files/config.json)"),
            "JSON should be regular link with .json extension, got: {}", updated_markdown
        );
        assert!(!updated_markdown.contains("![Config]"), "JSON should not be image link");
        
        // Verify: CSV converted to regular link with .csv
        assert!(
            updated_markdown.contains("[Data](mixed_files/data.csv)"),
            "CSV should be regular link with .csv extension"
        );
        assert!(!updated_markdown.contains("![Data]"), "CSV should not be image link");
        
        // Verify: Real PNG stays as image link
        assert!(
            updated_markdown.contains("![Logo](mixed_files/logo.png)"),
            "Real PNG should remain as image link"
        );
        
        // Verify: EML converted to regular link with .eml
        assert!(
            updated_markdown.contains("[Email](mixed_files/email.eml)"),
            "EML should be regular link with .eml extension"
        );
        assert!(!updated_markdown.contains("![Email]"), "EML should not be image link");
        
        // Verify all files copied with correct extensions
        assert!(parent.join("mixed_files/config.json").exists());
        assert!(parent.join("mixed_files/data.csv").exists());
        assert!(parent.join("mixed_files/logo.png").exists());
        assert!(parent.join("mixed_files/email.eml").exists());
    }

    #[test]
    fn test_file_correction_preserves_alt_text() {
        use std::io::Write;
        
        // Verify that alt text is preserved when converting from image to regular link
        
        let temp_dir = TempDir::new().unwrap();
        let parent = temp_dir.path();
        
        let source_dir = parent.join("source");
        let attachments_dir = source_dir.join("attachments");
        fs::create_dir_all(&attachments_dir).unwrap();
        
        let json_path = attachments_dir.join("data.png");
        let mut json_file = fs::File::create(&json_path).unwrap();
        // Need >20 bytes for JSON detection
        json_file.write_all(b"{\"key\": \"value\", \"number\": 42}").unwrap();
        drop(json_file);
        
        let markdown = "# Test\n\n![Important Configuration Data](data.png)\n";
        let output_path = parent.join("output.md");
        
        let result = copy_resources_and_update_links(markdown, &output_path, &source_dir);
        let updated_markdown = result.unwrap();
        
        // Verify: Alt text is preserved in the regular link
        assert!(
            updated_markdown.contains("[Important Configuration Data](output_files/data.json)"),
            "Alt text should be preserved as link text, got: {}", updated_markdown
        );
    }

    #[test]
    fn test_zip_file_type_correction() {
        use std::io::Write;
        
        // Test that ZIP files misnamed as PNG get corrected
        
        let temp_dir = TempDir::new().unwrap();
        let parent = temp_dir.path();
        
        let source_dir = parent.join("source");
        let attachments_dir = source_dir.join("attachments");
        fs::create_dir_all(&attachments_dir).unwrap();
        
        // Create ZIP file with .png extension (ZIP magic: PK\x03\x04)
        let zip_path = attachments_dir.join("archive.png");
        let mut zip_file = fs::File::create(&zip_path).unwrap();
        zip_file.write_all(&[0x50, 0x4B, 0x03, 0x04]).unwrap(); // ZIP magic bytes
        drop(zip_file);
        
        let markdown = "# Files\n\n![Archive](archive.png)\n";
        let output_path = parent.join("doc.md");
        
        let result = copy_resources_and_update_links(markdown, &output_path, &source_dir);
        let updated_markdown = result.unwrap();
        
        // Verify: Should be regular link with .zip extension
        assert!(
            updated_markdown.contains("[Archive](doc_files/archive.zip)"),
            "Should convert to regular link with .zip extension, got: {}", updated_markdown
        );
        assert!(!updated_markdown.contains("![Archive]"));
        
        // Verify: File copied with .zip extension
        assert!(parent.join("doc_files/archive.zip").exists());
    }

    #[test]
    fn test_docx_file_detection_and_conversion_e2e() {
        use std::io::Write;
        use zip::ZipWriter;
        
        // E2E Test: DOCX file misnamed as PNG should be converted to regular file link
        // This simulates the real-world issue: files exported with .png extension that are actually DOCX
        
        let temp_dir = TempDir::new().unwrap();
        let parent = temp_dir.path();
        
        let source_dir = parent.join("source");
        let files_dir = source_dir.join("source_files");
        fs::create_dir_all(&files_dir).unwrap();
        
        // Create a real DOCX file with .png extension
        // DOCX is a ZIP archive containing [Content_Types].xml and other Office structure
        let docx_path = files_dir.join("report_image-2024-9-20_21-35-7.png");
        let docx_file = fs::File::create(&docx_path).unwrap();
        let mut zip_writer = ZipWriter::new(docx_file);
        
        // Add [Content_Types].xml - signature that identifies Office documents
        let content_types_xml = r#"<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<Types xmlns="http://schemas.openxmlformats.org/package/2006/content-types">
  <Default Extension="rels" ContentType="application/vnd.openxmlformats-package.relationships+xml"/>
  <Default Extension="xml" ContentType="application/xml"/>
  <Override PartName="/word/document.xml" ContentType="application/vnd.openxmlformats-officedocument.wordprocessingml.document.main+xml"/>
</Types>"#;
        
        zip_writer.start_file("[Content_Types].xml", Default::default()).unwrap();
        zip_writer.write_all(content_types_xml.as_bytes()).unwrap();
        
        // Add word/document.xml - signature for DOCX format
        let document_xml = r#"<?xml version="1.0" encoding="UTF-8"?>
<w:document xmlns:w="http://schemas.openxmlformats.org/wordprocessingml/2006/main">
  <w:body>
    <w:p>
      <w:r>
        <w:t>Sample Report</w:t>
      </w:r>
    </w:p>
  </w:body>
</w:document>"#;
        
        zip_writer.start_file("word/document.xml", Default::default()).unwrap();
        zip_writer.write_all(document_xml.as_bytes()).unwrap();
        drop(zip_writer);
        
        // Create markdown with image link to the DOCX file
        let markdown = "# Document Report\n\nPlease review the attached document:\n\n![Important Report](report_image-2024-9-20_21-35-7.png)\n\nEnd of report.";
        let output_path = parent.join("report.md");
        
        // Process the markdown - should detect DOCX and convert image link to regular link
        let result = copy_resources_and_update_links(markdown, &output_path, &source_dir);
        let updated_markdown = result.unwrap();
        
        // Verify: Image link should be converted to regular file link
        assert!(
            updated_markdown.contains("[Important Report](report_files/report_image-2024-9-20_21-35-7.docx)"),
            "DOCX file should be converted to regular link with .docx extension, got: {}", updated_markdown
        );
        
        // Verify: Image markdown syntax should be removed
        assert!(
            !updated_markdown.contains("![Important Report](report_image-2024-9-20_21-35-7.png)"),
            "Original image link should not exist in output"
        );
        
        // Verify: File should be copied with corrected .docx extension
        let expected_file = parent.join("report_files/report_image-2024-9-20_21-35-7.docx");
        assert!(
            expected_file.exists(),
            "DOCX file should be copied with .docx extension at {}", expected_file.display()
        );
        
        // Verify: Original .png file should not exist in output (only .docx)
        let wrong_ext_file = parent.join("report_files/report_image-2024-9-20_21-35-7.png");
        assert!(
            !wrong_ext_file.exists(),
            "Original .png file should not exist in output, only .docx"
        );
        
        Logger::success("E2E test passed: DOCX detection and conversion working correctly");
    }

    #[test]
    fn test_xlsx_file_detection_e2e() {
        use std::io::Write;
        use zip::ZipWriter;
        
        // E2E Test: XLSX file misnamed as PNG should be converted to regular file link
        
        let temp_dir = TempDir::new().unwrap();
        let parent = temp_dir.path();
        
        let source_dir = parent.join("source");
        let files_dir = source_dir.join("source_files");
        fs::create_dir_all(&files_dir).unwrap();
        
        // Create XLSX file with .png extension
        let xlsx_path = files_dir.join("data_sheet.png");
        let xlsx_file = fs::File::create(&xlsx_path).unwrap();
        let mut zip_writer = ZipWriter::new(xlsx_file);
        
        // XLSX specific structure with xl/ prefix
        let content_types_xml = r#"<?xml version="1.0"?>
<Types xmlns="http://schemas.openxmlformats.org/package/2006/content-types">
  <Default Extension="rels" ContentType="application/vnd.openxmlformats-package.relationships+xml"/>
  <Override PartName="/xl/workbook.xml" ContentType="application/vnd.openxmlformats-officedocument.spreadsheetml.sheet.main+xml"/>
</Types>"#;
        
        zip_writer.start_file("[Content_Types].xml", Default::default()).unwrap();
        zip_writer.write_all(content_types_xml.as_bytes()).unwrap();
        
        // Add xl/workbook.xml for XLSX identification
        let workbook_xml = r#"<?xml version="1.0"?>
<workbook xmlns="http://schemas.openxmlformats.org/spreadsheetml/2006/main">
  <sheets>
    <sheet name="Sheet1" sheetId="1" r:id="rId1"/>
  </sheets>
</workbook>"#;
        
        zip_writer.start_file("xl/workbook.xml", Default::default()).unwrap();
        zip_writer.write_all(workbook_xml.as_bytes()).unwrap();
        drop(zip_writer);
        
        let markdown = "# Data Analysis\n\n![Sales Data](data_sheet.png)\n\n";
        let output_path = parent.join("analysis.md");
        
        let result = copy_resources_and_update_links(markdown, &output_path, &source_dir);
        let updated_markdown = result.unwrap();
        
        // Verify: Converted to regular link with .xlsx extension
        assert!(
            updated_markdown.contains("[Sales Data](analysis_files/data_sheet.xlsx)"),
            "XLSX should be detected and converted, got: {}", updated_markdown
        );
        
        // Verify: File exists with .xlsx extension
        assert!(
            parent.join("analysis_files/data_sheet.xlsx").exists(),
            "XLSX file should be copied with .xlsx extension"
        );
    }

    #[test]
    fn test_real_images_remain_as_image_links() {
        use std::io::Write;
        
        // E2E Test: Verify that actual PNG images remain as image links
        // This ensures we don't break valid image handling
        
        let temp_dir = TempDir::new().unwrap();
        let parent = temp_dir.path();
        
        let source_dir = parent.join("source");
        let files_dir = source_dir.join("source_files");
        fs::create_dir_all(&files_dir).unwrap();
        
        // Create a real PNG file (minimal valid PNG)
        // PNG magic bytes: 89 50 4E 47 (and more header)
        let png_path = files_dir.join("screenshot.png");
        let mut png_file = fs::File::create(&png_path).unwrap();
        // Minimal PNG header
        png_file.write_all(&[
            0x89, 0x50, 0x4E, 0x47, 0x0D, 0x0A, 0x1A, 0x0A, // PNG signature
            0x00, 0x00, 0x00, 0x0D, // IHDR length
            0x49, 0x48, 0x44, 0x52, // IHDR
            0x00, 0x00, 0x00, 0x01, // width: 1
            0x00, 0x00, 0x00, 0x01, // height: 1
            0x08, 0x02, 0x00, 0x00, 0x00, // bit depth, color type, etc
            0x90, 0x77, 0x53, 0xDE, // CRC
        ]).unwrap();
        drop(png_file);
        
        let markdown = "# Images\n\n![Screenshot](screenshot.png)\n\n";
        let output_path = parent.join("doc.md");
        
        let result = copy_resources_and_update_links(markdown, &output_path, &source_dir);
        let updated_markdown = result.unwrap();
        
        // Verify: Real PNG image should remain as image link
        assert!(
            updated_markdown.contains("![Screenshot]"),
            "Real PNG image should remain as image link, got: {}", updated_markdown
        );
        
        // Verify: Should be in the image directory or embedded
        assert!(
            updated_markdown.contains("screenshot.png") || updated_markdown.contains("screenshot"),
            "PNG file reference should be preserved"
        );
    }

    #[test]
    fn test_remove_first_h1_from_html() {
        // Test that first H1 is removed but content preserved
        let html = r#"<html><body><h1>Page Title</h1><p>Content</p></body></html>"#;
        let result = remove_first_h1_from_html(html);
        
        // H1 tag should be gone
        assert!(!result.contains("<h1>"), "H1 tag should be removed");
        
        // But text content should be preserved
        assert!(result.contains("Page Title"), "H1 text should be preserved");
        assert!(result.contains("<p>Content</p>"), "Other content should remain");
    }

    #[test]
    fn test_remove_first_h1_preserves_multiple_h1s() {
        // Only the first H1 should be removed
        let html = r#"<html><body><h1>First</h1><p>Text</p><h1>Second</h1></body></html>"#;
        let result = remove_first_h1_from_html(html);
        
        // First H1 should be converted to text
        assert!(result.contains("First"), "First H1 text preserved");
        
        // Second H1 should remain as tag
        assert!(result.contains("<h1>Second</h1>"), "Second H1 tag should remain");
    }

    #[test]
    fn test_remove_first_h1_no_h1_present() {
        // Should handle HTML without H1
        let html = r#"<html><body><p>No heading here</p></body></html>"#;
        let result = remove_first_h1_from_html(html);
        
        assert_eq!(result, html, "Should return unchanged HTML when no H1 present");
    }
}


